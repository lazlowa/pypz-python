<?xml-stylesheet type="text/xsl" href="../../../../../../mypy-html.xslt"?><mypy-report-file name="core\src\pypz\core\specs\utils.py" module="core.src.pypz.core.specs.utils"><line any_info="No Anys on this line!" content="# =============================================================================" number="1" precision="empty"/><line any_info="No Anys on this line!" content="# Copyright (c) 2024 by Laszlo Anka. All rights reserved." number="2" precision="empty"/><line any_info="No Anys on this line!" content="#" number="3" precision="empty"/><line any_info="No Anys on this line!" content="# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);" number="4" precision="empty"/><line any_info="No Anys on this line!" content="# you may not use this file except in compliance with the License." number="5" precision="empty"/><line any_info="No Anys on this line!" content="# You may obtain a copy of the License at" number="6" precision="empty"/><line any_info="No Anys on this line!" content="#" number="7" precision="empty"/><line any_info="No Anys on this line!" content="#     http://www.apache.org/licenses/LICENSE-2.0" number="8" precision="empty"/><line any_info="No Anys on this line!" content="#" number="9" precision="empty"/><line any_info="No Anys on this line!" content="# Unless required by applicable law or agreed to in writing, software" number="10" precision="empty"/><line any_info="No Anys on this line!" content="# distributed under the License is distributed on an &quot;AS IS&quot; BASIS," number="11" precision="empty"/><line any_info="No Anys on this line!" content="# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied." number="12" precision="empty"/><line any_info="No Anys on this line!" content="# See the License for the specific language governing permissions and" number="13" precision="empty"/><line any_info="No Anys on this line!" content="# limitations under the License." number="14" precision="empty"/><line any_info="No Anys on this line!" content="# =============================================================================" number="15" precision="empty"/><line any_info="No Anys on this line!" content="import types" number="16" precision="precise"/><line any_info="No Anys on this line!" content="import re" number="17" precision="precise"/><line any_info="No Anys on this line!" content="from importlib import import_module" number="18" precision="precise"/><line any_info="No Anys on this line!" content="from typing import Callable, Any, Iterable" number="19" precision="precise"/><line any_info="No Anys on this line!" content="" number="20" precision="empty"/><line any_info="No Anys on this line!" content="IncludedCascadingParameterPrefix = &quot;#&quot;" number="21" precision="precise"/><line any_info="No Anys on this line!" content="&quot;&quot;&quot;" number="22" precision="empty"/><line any_info="No Anys on this line!" content="This strings denotes a cascading parameter. Included cascading parameter means" number="23" precision="empty"/><line any_info="No Anys on this line!" content="that the model defines this parameter will get it provided as well the sub instances." number="24" precision="empty"/><line any_info="No Anys on this line!" content="&quot;&quot;&quot;" number="25" precision="empty"/><line any_info="No Anys on this line!" content="" number="26" precision="empty"/><line any_info="No Anys on this line!" content="ExcludedCascadingParameterPrefix = &quot;&gt;&quot;" number="27" precision="precise"/><line any_info="No Anys on this line!" content="&quot;&quot;&quot;" number="28" precision="empty"/><line any_info="No Anys on this line!" content="This strings denotes a cascading parameter. Excluded cascading parameter means" number="29" precision="empty"/><line any_info="No Anys on this line!" content="that the model defines this parameter will NOT get it provided ONLY the sub instances." number="30" precision="empty"/><line any_info="No Anys on this line!" content="&quot;&quot;&quot;" number="31" precision="empty"/><line any_info="No Anys on this line!" content="" number="32" precision="empty"/><line any_info="No Anys on this line!" content="" number="33" precision="empty"/><line any_info="No Anys on this line!" content="class InstanceParameters(dict):" number="34" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="35" precision="empty"/><line any_info="No Anys on this line!" content="    This class represents the parameters of the instance organized into" number="36" precision="empty"/><line any_info="No Anys on this line!" content="    a dictionary. The necessity of extending the builtin dict is that" number="37" precision="empty"/><line any_info="No Anys on this line!" content="    the parameter changes shall be watched because the expected parameters" number="38" precision="empty"/><line any_info="No Anys on this line!" content="    that are represented by instance attributes shall be updated as well," number="39" precision="empty"/><line any_info="No Anys on this line!" content="    so we need to be able to define callbacks on parameter set." number="40" precision="empty"/><line any_info="No Anys on this line!" content="    The mentioned default callbacks are defined in the Instance class." number="41" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="42" precision="empty"/><line any_info="No Anys on this line!" content="" number="43" precision="empty"/><line any_info="No Anys on this line!" content="    def __init__(self, *args, **kwargs):" number="44" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x3)" content="        super().__init__(*args, **kwargs)" number="45" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x1)&#10;Unannotated (x2)" content="        self.__update_callbacks: dict[str, list[Callable[[Any], None]]] = dict()" number="46" precision="any"/><line any_info="No Anys on this line!" content="" number="47" precision="empty"/><line any_info="No Anys on this line!" content="    def __setitem__(self, name, value):" number="48" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x6)" content="        if ((name not in self) or (value != self[name])):" number="49" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x3)" content="            super().__setitem__(name, value)" number="50" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)" content="            if name in self.__update_callbacks:" number="51" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)" content="                for callback in self.__update_callbacks[name]:" number="52" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x3)" content="                    callback(value)" number="53" precision="any"/><line any_info="No Anys on this line!" content="" number="54" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x2)" content="    def update(self, __m, **kwargs) -&gt; None:" number="55" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)" content="        super().update(__m, **kwargs)" number="56" precision="any"/><line any_info="No Anys on this line!" content="" number="57" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x5)" content="        for name, value in __m.items():" number="58" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x7)&#10;Omitted Generics (x1)&#10;Explicit (x1)" content="            if ((name not in self) or (value != self[name])) and (name in self.__update_callbacks):" number="59" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x3)&#10;Unannotated (x1)" content="                for callback in self.__update_callbacks[name]:" number="60" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x1)&#10;Unannotated (x1)" content="                    callback(value)" number="61" precision="any"/><line any_info="No Anys on this line!" content="" number="62" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x2)&#10;Explicit (x1)" content="    def on_parameter_update(self, name, callback: Callable[[Any], None]):" number="63" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)&#10;Explicit (x1)" content="        if name not in self.__update_callbacks:" number="64" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x2)&#10;Omitted Generics (x3)&#10;Unannotated (x1)" content="            self.__update_callbacks[name] = list()" number="65" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x4)&#10;Unannotated (x1)" content="        self.__update_callbacks[name].append(callback)" number="66" precision="any"/><line any_info="No Anys on this line!" content="" number="67" precision="empty"/><line any_info="No Anys on this line!" content="" number="68" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="def resolve_dependency_graph(instances: set | Iterable) -&gt; list[set]:" number="69" precision="imprecise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="70" precision="empty"/><line any_info="No Anys on this line!" content="    This method can resolve the dependencies along instances provided in the instance set." number="71" precision="empty"/><line any_info="No Anys on this line!" content="    Dependency can be formulated between instances via depends_on(). Resolution means that" number="72" precision="empty"/><line any_info="No Anys on this line!" content="    the instances will be ordered into a list of sets, where each outer list represents" number="73" precision="empty"/><line any_info="No Anys on this line!" content="    a dependency level and each inner sets hold the instances on that level. For example," number="74" precision="empty"/><line any_info="No Anys on this line!" content="    if there are instances w/o any dependencies, then those will be placed to level 0, which" number="75" precision="empty"/><line any_info="No Anys on this line!" content="    is the list[0]. On level 1 all the instances are placed that has dependencies to level 0" number="76" precision="empty"/><line any_info="No Anys on this line!" content="    instances and so on." number="77" precision="empty"/><line any_info="No Anys on this line!" content="" number="78" precision="empty"/><line any_info="No Anys on this line!" content="    :param instances: set of instances to resolve the dependencies across" number="79" precision="empty"/><line any_info="No Anys on this line!" content="    :return: list of sets, where the list represents dependency levels and set the instances on it" number="80" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="81" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="    if 0 &lt; len(instances):" number="82" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="        resolved_instances = set()" number="83" precision="precise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="        dependency_level_list = list()" number="84" precision="precise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x12)" content="        instance_set = instances if isinstance(instances, set) else set(instances)" number="85" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="86" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x1)" content="        for level in range(len(instance_set)):" number="87" precision="imprecise"/><line any_info="No Anys on this line!" content="            # We cannot have more dependency levels than instances we have, hence" number="88" precision="empty"/><line any_info="No Anys on this line!" content="            # the outer loop can always create a dependency level, where the instances" number="89" precision="empty"/><line any_info="No Anys on this line!" content="            # on the actual level will be stored" number="90" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x3)&#10;Omitted Generics (x3)" content="            dependency_level_list.append(set())" number="91" precision="any"/><line any_info="No Anys on this line!" content="" number="92" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="            for instance in instance_set:" number="93" precision="any"/><line any_info="No Anys on this line!" content="                # It is possible that instances have dependencies that are not present" number="94" precision="empty"/><line any_info="No Anys on this line!" content="                # in the list provided as argument, hence we need to create an intersection," number="95" precision="empty"/><line any_info="No Anys on this line!" content="                # so we attempt to resolve dependencies only present in the provided list." number="96" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x9)" content="                available_dependencies = instance.get_protected().get_depends_on().intersection(instance_set)" number="97" precision="any"/><line any_info="No Anys on this line!" content="" number="98" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unannotated (x1)" content="                if (instance not in resolved_instances) and \" number="99" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="                        ((0 == len(available_dependencies)) or" number="100" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)&#10;Unannotated (x1)" content="                         available_dependencies.issubset(resolved_instances)):" number="101" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x1)" content="                    dependency_level_list[level].add(instance)" number="102" precision="any"/><line any_info="No Anys on this line!" content="" number="103" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unannotated (x2)" content="            resolved_instances.update(dependency_level_list[level])" number="104" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="            if len(resolved_instances) == len(instances):" number="105" precision="imprecise"/><line any_info="No Anys on this line!" content="                # Early termination, since all instance dependencies have been resolved" number="106" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x1)" content="                return dependency_level_list" number="107" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="108" precision="empty"/><line any_info="No Anys on this line!" content="        # If resolution could not be concluded in N*N steps, then it is very possible" number="109" precision="empty"/><line any_info="No Anys on this line!" content="        # that there is a circular dependency. Notice that the method depends_on()" number="110" precision="empty"/><line any_info="No Anys on this line!" content="        # checks for circular dependencies, still there is an edge case, where that" number="111" precision="empty"/><line any_info="No Anys on this line!" content="        # list is altered outside of that method." number="112" precision="empty"/><line any_info="No Anys on this line!" content="        raise RecursionError(&quot;Circular dependency detected in instance dependencies&quot;)" number="113" precision="precise"/><line any_info="No Anys on this line!" content="" number="114" precision="empty"/><line any_info="No Anys on this line!" content="    return []" number="115" precision="empty"/><line any_info="No Anys on this line!" content="" number="116" precision="empty"/><line any_info="No Anys on this line!" content="" number="117" precision="empty"/><line any_info="No Anys on this line!" content="class SingletonAccessWrapper(type):" number="118" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="119" precision="empty"/><line any_info="No Anys on this line!" content="    This metaclass extends the AccessWrapper class with the functionality" number="120" precision="empty"/><line any_info="No Anys on this line!" content="    of caching AccessWrapper objects based on the Instance object. This" number="121" precision="empty"/><line any_info="No Anys on this line!" content="    allows to reuse the AccessWrapper object instead of creating a new one." number="122" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="123" precision="empty"/><line any_info="No Anys on this line!" content="" number="124" precision="empty"/><line any_info="No Anys on this line!" content="    __singletons: dict[int, 'AccessWrapper'] = dict()" number="125" precision="precise"/><line any_info="No Anys on this line!" content="" number="126" precision="empty"/><line any_info="No Anys on this line!" content="    def __call__(cls, instance, *args, **kwargs):" number="127" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x3)&#10;Explicit (x2)" content="        if id(instance) in SingletonAccessWrapper.__singletons:" number="128" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Explicit (x2)" content="            return SingletonAccessWrapper.__singletons[id(instance)]" number="129" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x6)&#10;Explicit (x2)" content="        instance_access = type.__call__(cls, instance, *args, **kwargs)" number="130" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Explicit (x2)" content="        SingletonAccessWrapper.__singletons[id(instance)] = instance_access" number="131" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)" content="        return instance_access" number="132" precision="any"/><line any_info="No Anys on this line!" content="" number="133" precision="empty"/><line any_info="No Anys on this line!" content="" number="134" precision="empty"/><line any_info="No Anys on this line!" content="class AccessWrapper(metaclass=SingletonAccessWrapper):" number="135" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="136" precision="empty"/><line any_info="No Anys on this line!" content="    This class wraps the access of the provided object's protected and private" number="137" precision="empty"/><line any_info="No Anys on this line!" content="    attributes into publicly accessible methods." number="138" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="139" precision="empty"/><line any_info="No Anys on this line!" content="" number="140" precision="empty"/><line any_info="No Anys on this line!" content="    PATTERN = r&quot;^(_[a-zA-Z0-9]+__|_(?!_))&quot;" number="141" precision="precise"/><line any_info="No Anys on this line!" content="" number="142" precision="empty"/><line any_info="No Anys on this line!" content="    def __init__(self, instance: object):" number="143" precision="precise"/><line any_info="No Anys on this line!" content="        # Wrapping methods" number="144" precision="empty"/><line any_info="No Anys on this line!" content="        # ================" number="145" precision="empty"/><line any_info="No Anys on this line!" content="" number="146" precision="empty"/><line any_info="No Anys on this line!" content="        for name in dir(instance):" number="147" precision="precise"/><line any_info="No Anys on this line!" content="            if hasattr(instance, name):" number="148" precision="precise"/><line any_info="Any Types on this line: &#10;Explicit (x14)&#10;Omitted Generics (x2)" content="                attr = getattr(instance, name)" number="149" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x4)" content="                if isinstance(attr, types.MethodType) and (not re.match(r&quot;^__\w+__$&quot;, name)):" number="150" precision="any"/><line any_info="No Anys on this line!" content="                    public_name = re.sub(AccessWrapper.PATTERN, &quot;&quot;, name)" number="151" precision="precise"/><line any_info="No Anys on this line!" content="                    if (not hasattr(instance, public_name)) or \" number="152" precision="precise"/><line any_info="Any Types on this line: &#10;Explicit (x16)&#10;Omitted Generics (x2)" content="                            (not isinstance(getattr(instance, public_name), types.MethodType)):" number="153" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x1)" content="                        self.__dict__[public_name] = attr" number="154" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="155" precision="empty"/><line any_info="No Anys on this line!" content="        # Wrapping fields" number="156" precision="empty"/><line any_info="No Anys on this line!" content="        # ===============" number="157" precision="empty"/><line any_info="No Anys on this line!" content="" number="158" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x4)" content="        for name, value in instance.__dict__.items():" number="159" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x2)" content="            object.__setattr__(self, name, value)" number="160" precision="any"/><line any_info="No Anys on this line!" content="" number="161" precision="empty"/><line any_info="No Anys on this line!" content="            if re.match(AccessWrapper.PATTERN, name):" number="162" precision="precise"/><line any_info="No Anys on this line!" content="                getter_name = re.sub(AccessWrapper.PATTERN, &quot;get_&quot;, name)" number="163" precision="precise"/><line any_info="No Anys on this line!" content="                if (not hasattr(instance, getter_name)) or \" number="164" precision="precise"/><line any_info="Any Types on this line: &#10;Explicit (x16)&#10;Omitted Generics (x2)" content="                        (not isinstance(getattr(instance, getter_name), types.MethodType)):" number="165" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x4)" content="                    self.__dict__[getter_name] = types.MethodType(lambda this, n=name: this.__dict__[n], self)" number="166" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="167" precision="empty"/><line any_info="No Anys on this line!" content="    def get_nested_instance(self, name):" number="168" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)" content="        return self.get_nested_instances()[name]" number="169" precision="any"/><line any_info="No Anys on this line!" content="" number="170" precision="empty"/><line any_info="No Anys on this line!" content="    def has_nested_instance(self, name):" number="171" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x3)" content="        return name in self.get_nested_instances()" number="172" precision="any"/><line any_info="No Anys on this line!" content="" number="173" precision="empty"/><line any_info="No Anys on this line!" content="    def __getattr__(self, name):" number="174" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x3)" content="        return self.__getattribute__(name)" number="175" precision="any"/><line any_info="No Anys on this line!" content="" number="176" precision="empty"/><line any_info="No Anys on this line!" content="" number="177" precision="empty"/><line any_info="No Anys on this line!" content="def load_class_by_name(class_name: str) -&gt; type:" number="178" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="179" precision="empty"/><line any_info="No Anys on this line!" content="    This method loads a class given its name by traversing its module path up" number="180" precision="empty"/><line any_info="No Anys on this line!" content="    to the class itself." number="181" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="182" precision="empty"/><line any_info="No Anys on this line!" content="" number="183" precision="empty"/><line any_info="No Anys on this line!" content="    if 0 &gt; class_name.find(&quot;.&quot;):" number="184" precision="precise"/><line any_info="No Anys on this line!" content="        raise ValueError(f&quot;Class loading error. Invalid class specifier: {class_name}; &quot;" number="185" precision="precise"/><line any_info="No Anys on this line!" content="                         f&quot;Class specifier must be composed of [PACKAGE_NAME.]MODULE_NAME:CLASS_NAME[.CLASS_NAME+]&quot;)" number="186" precision="empty"/><line any_info="No Anys on this line!" content="    trimmed_name = class_name.replace(&quot;&lt;class '&quot;, &quot;&quot;).replace(&quot;'&gt;&quot;, &quot;&quot;)" number="187" precision="precise"/><line any_info="No Anys on this line!" content="" number="188" precision="empty"/><line any_info="No Anys on this line!" content="    loaded = None" number="189" precision="precise"/><line any_info="No Anys on this line!" content="    for segment in trimmed_name.split(&quot;.&quot;):" number="190" precision="precise"/><line any_info="No Anys on this line!" content="        if loaded is None:" number="191" precision="precise"/><line any_info="No Anys on this line!" content="            loaded = import_module(segment)" number="192" precision="precise"/><line any_info="No Anys on this line!" content="        else:" number="193" precision="empty"/><line any_info="No Anys on this line!" content="            if hasattr(loaded, segment):" number="194" precision="unanalyzed"/><line any_info="No Anys on this line!" content="                loaded = getattr(loaded, segment)" number="195" precision="unanalyzed"/><line any_info="No Anys on this line!" content="            else:" number="196" precision="empty"/><line any_info="No Anys on this line!" content="                try:" number="197" precision="empty"/><line any_info="No Anys on this line!" content="                    loaded = import_module(loaded.__name__ + &quot;.&quot; + segment)" number="198" precision="unanalyzed"/><line any_info="No Anys on this line!" content="                except ModuleNotFoundError:" number="199" precision="unanalyzed"/><line any_info="No Anys on this line!" content="                    raise AttributeError(f&quot;Class not found: {loaded.__name__}.{segment}&quot;)" number="200" precision="unanalyzed"/><line any_info="No Anys on this line!" content="" number="201" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x2)" content="    if not isinstance(loaded, type):" number="202" precision="precise"/><line any_info="No Anys on this line!" content="        raise TypeError(f&quot;Specified class name results in a non-type: {loaded}&quot;)" number="203" precision="precise"/><line any_info="No Anys on this line!" content="" number="204" precision="empty"/><line any_info="No Anys on this line!" content="    return loaded" number="205" precision="unanalyzed"/><line any_info="No Anys on this line!" content="" number="206" precision="empty"/><line any_info="No Anys on this line!" content="" number="207" precision="empty"/><line any_info="No Anys on this line!" content="def remove_super_classes(classes: set[type]) -&gt; set[type]:" number="208" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="209" precision="empty"/><line any_info="No Anys on this line!" content="    This function will remove the classes from the set, which are super class for any" number="210" precision="empty"/><line any_info="No Anys on this line!" content="    of the others, hence redundant. It is used to clean up the Instance specs to avoid" number="211" precision="empty"/><line any_info="No Anys on this line!" content="    Deadly Diamond of Death situation at dynamic class creation." number="212" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="213" precision="empty"/><line any_info="No Anys on this line!" content="" number="214" precision="empty"/><line any_info="No Anys on this line!" content="    return {cls for cls in classes if not any(issubclass(pot, cls) and cls is not pot for pot in classes)}" number="215" precision="precise"/></mypy-report-file>