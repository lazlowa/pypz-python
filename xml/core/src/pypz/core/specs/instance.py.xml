<?xml-stylesheet type="text/xsl" href="../../../../../../mypy-html.xslt"?><mypy-report-file name="core\src\pypz\core\specs\instance.py" module="core.src.pypz.core.specs.instance"><line any_info="No Anys on this line!" content="# =============================================================================" number="1" precision="empty"/><line any_info="No Anys on this line!" content="# Copyright (c) 2024 by Laszlo Anka. All rights reserved." number="2" precision="empty"/><line any_info="No Anys on this line!" content="#" number="3" precision="empty"/><line any_info="No Anys on this line!" content="# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);" number="4" precision="empty"/><line any_info="No Anys on this line!" content="# you may not use this file except in compliance with the License." number="5" precision="empty"/><line any_info="No Anys on this line!" content="# You may obtain a copy of the License at" number="6" precision="empty"/><line any_info="No Anys on this line!" content="#" number="7" precision="empty"/><line any_info="No Anys on this line!" content="#     http://www.apache.org/licenses/LICENSE-2.0" number="8" precision="empty"/><line any_info="No Anys on this line!" content="#" number="9" precision="empty"/><line any_info="No Anys on this line!" content="# Unless required by applicable law or agreed to in writing, software" number="10" precision="empty"/><line any_info="No Anys on this line!" content="# distributed under the License is distributed on an &quot;AS IS&quot; BASIS," number="11" precision="empty"/><line any_info="No Anys on this line!" content="# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied." number="12" precision="empty"/><line any_info="No Anys on this line!" content="# See the License for the specific language governing permissions and" number="13" precision="empty"/><line any_info="No Anys on this line!" content="# limitations under the License." number="14" precision="empty"/><line any_info="No Anys on this line!" content="# =============================================================================" number="15" precision="empty"/><line any_info="No Anys on this line!" content="import inspect" number="16" precision="precise"/><line any_info="No Anys on this line!" content="import re" number="17" precision="precise"/><line any_info="No Anys on this line!" content="import sys" number="18" precision="precise"/><line any_info="No Anys on this line!" content="import types" number="19" precision="precise"/><line any_info="No Anys on this line!" content="from abc import ABCMeta, ABC, abstractmethod" number="20" precision="precise"/><line any_info="No Anys on this line!" content="from typing import Type, Any, TypeVar, Generic, Optional" number="21" precision="precise"/><line any_info="No Anys on this line!" content="" number="22" precision="empty"/><line any_info="No Anys on this line!" content="import yaml" number="23" precision="precise"/><line any_info="No Anys on this line!" content="" number="24" precision="empty"/><line any_info="No Anys on this line!" content="from pypz.core.commons.utils import TemplateResolver, is_type_allowed, convert_to_dict" number="25" precision="any"/><line any_info="No Anys on this line!" content="from pypz.core.commons.parameters import retrieve_parameters, ExpectedParameter, allowed_param_types" number="26" precision="any"/><line any_info="No Anys on this line!" content="from pypz.core.specs.dtos import InstanceDTO, SpecDTO" number="27" precision="any"/><line any_info="No Anys on this line!" content="from pypz.core.specs.utils import InstanceParameters, AccessWrapper, load_class_by_name, remove_super_classes, \" number="28" precision="any"/><line any_info="No Anys on this line!" content="    IncludedCascadingParameterPrefix, ExcludedCascadingParameterPrefix" number="29" precision="empty"/><line any_info="No Anys on this line!" content="" number="30" precision="empty"/><line any_info="No Anys on this line!" content="" number="31" precision="empty"/><line any_info="No Anys on this line!" content="class RegisteredInterface:" number="32" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="33" precision="empty"/><line any_info="No Anys on this line!" content="    This is a marker interface with the sole purpose to identify the native specs interfaces." number="34" precision="empty"/><line any_info="No Anys on this line!" content="    It is necessary to separate the implemented and multiple inherited classes from the" number="35" precision="empty"/><line any_info="No Anys on this line!" content="    actual plugin interfaces." number="36" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="37" precision="empty"/><line any_info="No Anys on this line!" content="    pass" number="38" precision="precise"/><line any_info="No Anys on this line!" content="" number="39" precision="empty"/><line any_info="No Anys on this line!" content="" number="40" precision="empty"/><line any_info="No Anys on this line!" content="class InterceptedInstance:" number="41" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="42" precision="empty"/><line any_info="No Anys on this line!" content="    This class represents an intercepted instance at init. Part of the feature set is that" number="43" precision="empty"/><line any_info="No Anys on this line!" content="    if you don't provide a name to an instance in its parent context, then its variable name" number="44" precision="empty"/><line any_info="No Anys on this line!" content="    is used as name. However, since there is no convenient way to provide the name of the variable" number="45" precision="empty"/><line any_info="No Anys on this line!" content="    holding the reference to the object into the object's __init__, we need to work around this." number="46" precision="empty"/><line any_info="No Anys on this line!" content="    The concept is that we intercept the instance creation, if no name has been provided through" number="47" precision="empty"/><line any_info="No Anys on this line!" content="    a metaclass. This metaclass creates an InterceptedInstance object instead of the real" number="48" precision="empty"/><line any_info="No Anys on this line!" content="    object. As next step, the Instance's __setattr__ is modified (since that is the only place," number="49" precision="empty"/><line any_info="No Anys on this line!" content="    where the variable name is given) so that, if it sees that an InterceptedInstance is to" number="50" precision="empty"/><line any_info="No Anys on this line!" content="    be assigned, it instead creates the original object, but this time with the name and the" number="51" precision="empty"/><line any_info="No Anys on this line!" content="    context object already provided. Hence, all the (nested) instances' __init__ will be" number="52" precision="empty"/><line any_info="No Anys on this line!" content="    performed with already available name and context." number="53" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="54" precision="empty"/><line any_info="No Anys on this line!" content="" number="55" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x1)&#10;Unannotated (x2)" content="    def __init__(self, instance_name: str, context_class: Type['Instance'], *args, **kwargs):" number="56" precision="any"/><line any_info="No Anys on this line!" content="        self.instance_name = instance_name" number="57" precision="precise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="        self.context_class = context_class" number="58" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unannotated (x1)" content="        self.args: tuple = args" number="59" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)&#10;Unannotated (x1)" content="        self.kwargs: dict = kwargs" number="60" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="61" precision="empty"/><line any_info="No Anys on this line!" content="" number="62" precision="empty"/><line any_info="No Anys on this line!" content="InterceptedInstanceType = TypeVar('InterceptedInstanceType')" number="63" precision="empty"/><line any_info="No Anys on this line!" content="&quot;&quot;&quot;" number="64" precision="empty"/><line any_info="No Anys on this line!" content="This type definition is necessary to allow proper typehints" number="65" precision="empty"/><line any_info="No Anys on this line!" content="of the objects created by the Instance class with the custom" number="66" precision="empty"/><line any_info="No Anys on this line!" content="metaclass. Without this type definition no hints will be given." number="67" precision="empty"/><line any_info="No Anys on this line!" content="&quot;&quot;&quot;" number="68" precision="empty"/><line any_info="No Anys on this line!" content="" number="69" precision="empty"/><line any_info="No Anys on this line!" content="" number="70" precision="empty"/><line any_info="No Anys on this line!" content="class InstanceInitInterceptor(ABCMeta):" number="71" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="72" precision="empty"/><line any_info="No Anys on this line!" content="    This metaclass has the responsibility to intercept the instance initialization and so" number="73" precision="empty"/><line any_info="No Anys on this line!" content="    ensure that instance name and context objects are resolved automatically, before" number="74" precision="empty"/><line any_info="No Anys on this line!" content="    executing the __init__ of the instance. For more information refer to InterceptedInstance." number="75" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="76" precision="empty"/><line any_info="No Anys on this line!" content="" number="77" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unannotated (x2)" content="    def __call__(cls: Type[InterceptedInstanceType], name: str = None, *args, **kwargs) -&gt; InterceptedInstanceType:" number="78" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="79" precision="empty"/><line any_info="No Anys on this line!" content="        This method is called, if a class object is being created, hence we can intercept" number="80" precision="empty"/><line any_info="No Anys on this line!" content="        the __init__ call. The following rules are considered for interception:" number="81" precision="empty"/><line any_info="No Anys on this line!" content="        - caller frame shall be an object and shall be an instance of Instance" number="82" precision="empty"/><line any_info="No Anys on this line!" content="        - name or context object is not provided" number="83" precision="empty"/><line any_info="No Anys on this line!" content="        In these cases is the Instance init intercepted, in any other cases a normal" number="84" precision="empty"/><line any_info="No Anys on this line!" content="        init invoked." number="85" precision="empty"/><line any_info="No Anys on this line!" content="" number="86" precision="empty"/><line any_info="No Anys on this line!" content="        :param name: instance name" number="87" precision="empty"/><line any_info="No Anys on this line!" content="        :param args: args" number="88" precision="empty"/><line any_info="No Anys on this line!" content="        :param kwargs: kwargs" number="89" precision="empty"/><line any_info="No Anys on this line!" content="        :return: either InterceptedInstance or normal object" number="90" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="91" precision="empty"/><line any_info="No Anys on this line!" content="" number="92" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x1)&#10;Error (x2)" content="        if (&quot;self&quot; in inspect.currentframe().f_back.f_locals) and \" number="93" precision="imprecise"/><line any_info="Any Types on this line: &#10;Explicit (x2)&#10;Error (x2)&#10;Omitted Generics (x4)&#10;Unannotated (x2)" content="                isinstance(inspect.currentframe().f_back.f_locals[&quot;self&quot;], Instance) and \" number="94" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)" content="                ((name is None) or (&quot;context&quot; not in kwargs)):" number="95" precision="imprecise"/><line any_info="Any Types on this line: &#10;Explicit (x6)&#10;Omitted Generics (x2)&#10;Unannotated (x4)" content="            return type.__call__(InterceptedInstance, name, cls, *args, **kwargs)" number="96" precision="any"/><line any_info="No Anys on this line!" content="" number="97" precision="empty"/><line any_info="No Anys on this line!" content="        if (name is None) or not re.match(r&quot;^[a-zA-Z_]+[a-zA-Z0-9_-]*$&quot;, name):" number="98" precision="precise"/><line any_info="No Anys on this line!" content="            raise AttributeError(f&quot;Invalid instance name: {name}; &quot;" number="99" precision="precise"/><line any_info="No Anys on this line!" content="                                 f&quot;Name must match pattern: ^[a-zA-Z0-9_]+[a-zA-Z0-9_-]*$&quot;)" number="100" precision="empty"/><line any_info="No Anys on this line!" content="" number="101" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x7)&#10;Omitted Generics (x1)&#10;Unannotated (x2)" content="        instance = type.__call__(cls, name, *args, **kwargs)" number="102" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x3)&#10;Unannotated (x2)" content="        instance.__on_init_finished__(*args, **kwargs)" number="103" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x1)" content="        return instance" number="104" precision="any"/><line any_info="No Anys on this line!" content="" number="105" precision="empty"/><line any_info="No Anys on this line!" content="" number="106" precision="empty"/><line any_info="No Anys on this line!" content="NestedInstanceType = TypeVar('NestedInstanceType', bound='Instance')" number="107" precision="empty"/><line any_info="No Anys on this line!" content="" number="108" precision="empty"/><line any_info="No Anys on this line!" content="" number="109" precision="empty"/><line any_info="No Anys on this line!" content="class Instance(Generic[NestedInstanceType], RegisteredInterface, ABC, metaclass=InstanceInitInterceptor):" number="110" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="111" precision="empty"/><line any_info="No Anys on this line!" content="    This class represents the instance specs that serves as base for" number="112" precision="empty"/><line any_info="No Anys on this line!" content="    all the other models. It abstracts all common features and functionalities" number="113" precision="empty"/><line any_info="No Anys on this line!" content="    that is required to maintain the actual instances like parameters" number="114" precision="empty"/><line any_info="No Anys on this line!" content="    or even multi level nested instances." number="115" precision="empty"/><line any_info="No Anys on this line!" content="" number="116" precision="empty"/><line any_info="No Anys on this line!" content="    :param name: name of the instance, if not provided, it will be attempted to deduce from the variable's name" number="117" precision="empty"/><line any_info="No Anys on this line!" content="    :param nested_instance_type: type of the expected nested instances" number="118" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="119" precision="empty"/><line any_info="No Anys on this line!" content="" number="120" precision="empty"/><line any_info="No Anys on this line!" content="    # ========= ctor ==========" number="121" precision="empty"/><line any_info="No Anys on this line!" content="" number="122" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)&#10;Unannotated (x2)" content="    def __init__(self, name: str = None," number="123" precision="any"/><line any_info="No Anys on this line!" content="                 nested_instance_type: Type[NestedInstanceType] = None," number="124" precision="precise"/><line any_info="No Anys on this line!" content="                 *args, **kwargs):" number="125" precision="empty"/><line any_info="No Anys on this line!" content="" number="126" precision="empty"/><line any_info="No Anys on this line!" content="        # Sanity checks" number="127" precision="empty"/><line any_info="No Anys on this line!" content="        # =============" number="128" precision="empty"/><line any_info="No Anys on this line!" content="" number="129" precision="empty"/><line any_info="No Anys on this line!" content="        if name is not None and not isinstance(name, str):" number="130" precision="precise"/><line any_info="No Anys on this line!" content="            raise TypeError(f&quot;Invalid instance name: {name} {type(name)}&quot;)" number="131" precision="unanalyzed"/><line any_info="No Anys on this line!" content="" number="132" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x8)&#10;Unannotated (x2)" content="        if nested_instance_type is not None and not issubclass(nested_instance_type, Instance):" number="133" precision="imprecise"/><line any_info="No Anys on this line!" content="            raise TypeError(f&quot;Invalid nested instance type: {nested_instance_type}. &quot;" number="134" precision="unanalyzed"/><line any_info="No Anys on this line!" content="                            f&quot;Must be an extension of {Instance}&quot;)" number="135" precision="empty"/><line any_info="No Anys on this line!" content="" number="136" precision="empty"/><line any_info="No Anys on this line!" content="        # Member declarations" number="137" precision="empty"/><line any_info="No Anys on this line!" content="        # ===================" number="138" precision="empty"/><line any_info="No Anys on this line!" content="" number="139" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x8)" content="        self.__nested_instance_type: Type[NestedInstanceType] | None = nested_instance_type" number="140" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="141" precision="empty"/><line any_info="No Anys on this line!" content="        Stores the specified type of the nested instances. This is required to" number="142" precision="empty"/><line any_info="No Anys on this line!" content="        be able to discover those instances" number="143" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="144" precision="empty"/><line any_info="No Anys on this line!" content="" number="145" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x2)" content="        self.__reference = kwargs[&quot;reference&quot;] if &quot;reference&quot; in kwargs else None" number="146" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="147" precision="empty"/><line any_info="No Anys on this line!" content="        Reference to the reference instance. If specified, then some instance internal" number="148" precision="empty"/><line any_info="No Anys on this line!" content="        configuration related attributes will refer to the attributes of the reference instance." number="149" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="150" precision="empty"/><line any_info="No Anys on this line!" content="" number="151" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)&#10;Unannotated (x3)" content="        self.__context: Instance = kwargs[&quot;context&quot;] if &quot;context&quot; in kwargs else None" number="152" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="153" precision="empty"/><line any_info="No Anys on this line!" content="        Reference to the context aka parent object. Derived automatically" number="154" precision="empty"/><line any_info="No Anys on this line!" content="        in the override implementation of __setattr__." number="155" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="156" precision="empty"/><line any_info="No Anys on this line!" content="" number="157" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x8)" content="        self.__nested_instances: dict[str, NestedInstanceType] = dict()" number="158" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="159" precision="empty"/><line any_info="No Anys on this line!" content="        This dictionary holds all the instances that are nested in the context" number="160" precision="empty"/><line any_info="No Anys on this line!" content="        of this instance object" number="161" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="162" precision="empty"/><line any_info="No Anys on this line!" content="" number="163" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="        self.__simple_name: str = name" number="164" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="165" precision="empty"/><line any_info="No Anys on this line!" content="        Name of the instance, which is represented by the object created from the" number="166" precision="empty"/><line any_info="No Anys on this line!" content="        implementation class. If not provided and there is a parent context, then" number="167" precision="empty"/><line any_info="No Anys on this line!" content="        the parent context will use the name of the variable." number="168" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="169" precision="empty"/><line any_info="No Anys on this line!" content="" number="170" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)" content="        self.__full_name: str = self.__simple_name \" number="171" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x8)" content="            if self.__context is None else self.__context.get_full_name() + &quot;.&quot; + self.__simple_name" number="172" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="173" precision="empty"/><line any_info="No Anys on this line!" content="        Full name of the instance which uniquely identifies it up to its topmost context." number="174" precision="empty"/><line any_info="No Anys on this line!" content="        For example, if an instance A has a parent context B, which has a parent context C," number="175" precision="empty"/><line any_info="No Anys on this line!" content="        then the full name of A is 'C.B.A'. This value is calculated and the result is" number="176" precision="empty"/><line any_info="No Anys on this line!" content="        stored after the first calculation to avoid recalculation every time." number="177" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="178" precision="empty"/><line any_info="No Anys on this line!" content="" number="179" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x10)" content="        self.__spec_name: str = &quot;:&quot;.join([self.__class__.__module__, self.__class__.__qualname__])" number="180" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="181" precision="empty"/><line any_info="No Anys on this line!" content="        The name of the spec constructed of module and qualified class name. Notice that we separate" number="182" precision="empty"/><line any_info="No Anys on this line!" content="        the module name and the class name so that we can identify them at loading by name." number="183" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="184" precision="empty"/><line any_info="No Anys on this line!" content="" number="185" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x8)" content="        self.__spec_classes: set = set([" number="186" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)" content="            spec_class for spec_class in self.__class__.__mro__" number="187" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)&#10;Unannotated (x2)" content="            if issubclass(spec_class, Instance) and (RegisteredInterface in spec_class.__bases__)" number="188" precision="precise"/><line any_info="No Anys on this line!" content="        ])" number="189" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="190" precision="empty"/><line any_info="No Anys on this line!" content="        Set of specs classes that are in the class hierarchy i.e., which specs classes are" number="191" precision="empty"/><line any_info="No Anys on this line!" content="        contributing to the implementation of this class" number="192" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="193" precision="empty"/><line any_info="No Anys on this line!" content="" number="194" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x5)&#10;Omitted Generics (x4)" content="        self.__expected_parameters: dict[str, ExpectedParameter] = retrieve_parameters(self, ExpectedParameter)" number="195" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="196" precision="empty"/><line any_info="No Anys on this line!" content="        Map of expected parameters defined as descriptor of the class. Key is the name of the parameter," number="197" precision="empty"/><line any_info="No Anys on this line!" content="        value is the parameter descriptor. Used to check, if an expected (described) parameter value" number="198" precision="empty"/><line any_info="No Anys on this line!" content="        shall be set upon instance parameter setting." number="199" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="200" precision="empty"/><line any_info="No Anys on this line!" content="" number="201" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)&#10;Unannotated (x2)&#10;Omitted Generics (x4)" content="        self.__parameters: InstanceParameters = self.__reference.__parameters \" number="202" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)&#10;Omitted Generics (x2)&#10;Unimported (x2)" content="            if self.__reference is not None else InstanceParameters()" number="203" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="204" precision="empty"/><line any_info="No Anys on this line!" content="        The interpreted instance parameters i.e., cascading and templates are interpreted" number="205" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="206" precision="empty"/><line any_info="No Anys on this line!" content="" number="207" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x11)&#10;Unannotated (x4)" content="        self.__depends_on: set = self.__reference.__depends_on if self.__reference is not None else set()" number="208" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="209" precision="empty"/><line any_info="No Anys on this line!" content="        Set of other instances that is this instance depending on. Note however that" number="210" precision="empty"/><line any_info="No Anys on this line!" content="        the type of the dependencies are checked dynamically in runtime, since dependencies" number="211" precision="empty"/><line any_info="No Anys on this line!" content="        can only be defined on the same type of instance." number="212" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="213" precision="empty"/><line any_info="No Anys on this line!" content="" number="214" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot; Registering expected parameter update. This means that, if a parameter has been set via" number="215" precision="empty"/><line any_info="No Anys on this line!" content="        the set_parameter() method, we need to make sure that the corresponding parameter object" number="216" precision="empty"/><line any_info="No Anys on this line!" content="        is updated as well. &quot;&quot;&quot;" number="217" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x4)&#10;Omitted Generics (x2)" content="        for param in self.__expected_parameters.values():" number="218" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x5)&#10;Omitted Generics (x2)" content="            self.__parameters.on_parameter_update(param.name," number="219" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x1)&#10;Omitted Generics (x2)" content="                                                  lambda value, p=param, instance=self: p.__set__(instance, value))" number="220" precision="any"/><line any_info="No Anys on this line!" content="" number="221" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot; It is clear that in python anything can be accessed, however methods and attributes that" number="222" precision="empty"/><line any_info="No Anys on this line!" content="            should not be used are hidden (at least from autocompletion) from the user, still with" number="223" precision="empty"/><line any_info="No Anys on this line!" content="            the following dynamically created method it is possible to access them so that the IDE" number="224" precision="empty"/><line any_info="No Anys on this line!" content="            is not complaining. &quot;&quot;&quot;" number="225" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x1)&#10;Omitted Generics (x4)&#10;Unimported (x2)" content="        object.__setattr__(self, &quot;get_protected&quot;, lambda this=self: AccessWrapper(this))" number="226" precision="any"/><line any_info="No Anys on this line!" content="" number="227" precision="empty"/><line any_info="No Anys on this line!" content="    # ========= overridable methods ==========" number="228" precision="empty"/><line any_info="No Anys on this line!" content="" number="229" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="230" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="    def _on_interrupt(self, system_signal: int = None) -&gt; None:" number="231" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="232" precision="empty"/><line any_info="No Anys on this line!" content="        This method can be implemented to react to interrupt signals like" number="233" precision="empty"/><line any_info="No Anys on this line!" content="        SIGINT, SIGTERM etc. The specs implementation can then execute interrupt" number="234" precision="empty"/><line any_info="No Anys on this line!" content="        logic e.g., early termination of loops." number="235" precision="empty"/><line any_info="No Anys on this line!" content="" number="236" precision="empty"/><line any_info="No Anys on this line!" content="        :param system_signal: id of the system signal that causes interrupt" number="237" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="238" precision="empty"/><line any_info="No Anys on this line!" content="        pass" number="239" precision="precise"/><line any_info="No Anys on this line!" content="" number="240" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="241" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="    def _on_error(self) -&gt; None:" number="242" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="243" precision="empty"/><line any_info="No Anys on this line!" content="        This method can be implemented to react to error events during" number="244" precision="empty"/><line any_info="No Anys on this line!" content="        execution. The error itself may come from arbitrary sources." number="245" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="246" precision="empty"/><line any_info="No Anys on this line!" content="        pass" number="247" precision="precise"/><line any_info="No Anys on this line!" content="" number="248" precision="empty"/><line any_info="No Anys on this line!" content="    # ========= public methods ==========" number="249" precision="empty"/><line any_info="No Anys on this line!" content="" number="250" precision="empty"/><line any_info="No Anys on this line!" content="    def get_context(self):" number="251" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)&#10;Omitted Generics (x2)" content="        return self.__context" number="252" precision="any"/><line any_info="No Anys on this line!" content="" number="253" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="    def get_simple_name(self) -&gt; str:" number="254" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="        return self.__simple_name" number="255" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="256" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="    def get_full_name(self) -&gt; str:" number="257" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="        return self.__full_name" number="258" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="259" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unannotated (x1)" content="    def get_parameter(self, name: str):" number="260" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)&#10;Omitted Generics (x2)" content="        return self.__parameters[name]" number="261" precision="any"/><line any_info="No Anys on this line!" content="" number="262" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="    def has_parameter(self, name: str) -&gt; bool:" number="263" precision="imprecise"/><line any_info="Any Types on this line: &#10;Unimported (x1)&#10;Omitted Generics (x2)" content="        return name in self.__parameters" number="264" precision="any"/><line any_info="No Anys on this line!" content="" number="265" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Explicit (x1)" content="    def set_parameter(self, name: str, value: Any) -&gt; None:" number="266" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="267" precision="empty"/><line any_info="No Anys on this line!" content="        Parameter setter method, which interprets the templates and handles cascading" number="268" precision="empty"/><line any_info="No Anys on this line!" content="        parameters. One can ignore setting values for existing parameters via the" number="269" precision="empty"/><line any_info="No Anys on this line!" content="        provided flag." number="270" precision="empty"/><line any_info="No Anys on this line!" content="" number="271" precision="empty"/><line any_info="No Anys on this line!" content="        :param name: parameter name" number="272" precision="empty"/><line any_info="No Anys on this line!" content="        :param value: parameter value" number="273" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="274" precision="empty"/><line any_info="No Anys on this line!" content="" number="275" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x5)&#10;Explicit (x1)" content="        resolved_value = TemplateResolver(&quot;${&quot;, &quot;}&quot;).resolve(value)" number="276" precision="any"/><line any_info="No Anys on this line!" content="" number="277" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x4)" content="        if not is_type_allowed(resolved_value, allowed_param_types):" number="278" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x2)&#10;Unimported (x2)" content="            raise TypeError(f&quot;Invalid parameter value type for '{name}': {type(resolved_value)}. &quot;" number="279" precision="any"/><line any_info="No Anys on this line!" content="                            f&quot;Allowed types: {allowed_param_types}&quot;)" number="280" precision="empty"/><line any_info="No Anys on this line!" content="" number="281" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x1)" content="        if name.startswith(ExcludedCascadingParameterPrefix):" number="282" precision="any"/><line any_info="No Anys on this line!" content="            &quot;&quot;&quot; Cascade the parameter further. Notice that the first leading" number="283" precision="empty"/><line any_info="No Anys on this line!" content="                cascaded specifier has been removed in the parameter name" number="284" precision="empty"/><line any_info="No Anys on this line!" content="                Notice that we copy the instances into a list, since there can be" number="285" precision="empty"/><line any_info="No Anys on this line!" content="                situations, where the list is modified during iteration via" number="286" precision="empty"/><line any_info="No Anys on this line!" content="                replication (e.g., replicationFactor cascaded from pipeline) &quot;&quot;&quot;" number="287" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x15)" content="            for nested_instance in list(self.__nested_instances.values()):" number="288" precision="imprecise"/><line any_info="Any Types on this line: &#10;Explicit (x1)&#10;Omitted Generics (x2)&#10;Unimported (x1)" content="                nested_instance.set_parameter(name[1:], resolved_value)" number="289" precision="any"/><line any_info="No Anys on this line!" content="        else:" number="290" precision="empty"/><line any_info="No Anys on this line!" content="            param_name = name" number="291" precision="precise"/><line any_info="Any Types on this line: &#10;Unimported (x1)" content="            if name.startswith(IncludedCascadingParameterPrefix):" number="292" precision="any"/><line any_info="No Anys on this line!" content="                &quot;&quot;&quot; Remove all the cascading specifier from the parameter name &quot;&quot;&quot;" number="293" precision="empty"/><line any_info="No Anys on this line!" content="                param_name = name \" number="294" precision="precise"/><line any_info="Any Types on this line: &#10;Unimported (x1)" content="                    .replace(IncludedCascadingParameterPrefix, &quot;&quot;) \" number="295" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x1)" content="                    .replace(ExcludedCascadingParameterPrefix, &quot;&quot;)" number="296" precision="any"/><line any_info="No Anys on this line!" content="" number="297" precision="empty"/><line any_info="No Anys on this line!" content="                &quot;&quot;&quot; Cascade the parameter further. Notice that the first leading" number="298" precision="empty"/><line any_info="No Anys on this line!" content="                    cascaded specifier has been removed in the parameter name &quot;&quot;&quot;" number="299" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x10)" content="                for nested_instance in self.__nested_instances.values():" number="300" precision="imprecise"/><line any_info="Any Types on this line: &#10;Explicit (x1)&#10;Omitted Generics (x2)&#10;Unimported (x1)" content="                    nested_instance.set_parameter(name[1:], resolved_value)" number="301" precision="any"/><line any_info="No Anys on this line!" content="" number="302" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)&#10;Omitted Generics (x2)" content="            self.__parameters[param_name] = resolved_value" number="303" precision="any"/><line any_info="No Anys on this line!" content="" number="304" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)" content="    def set_parameters(self, parameters: dict) -&gt; None:" number="305" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="306" precision="empty"/><line any_info="No Anys on this line!" content="        Convenience parameter setter method for dicts, where all key value pair will be" number="307" precision="empty"/><line any_info="No Anys on this line!" content="        set separately" number="308" precision="empty"/><line any_info="No Anys on this line!" content="" number="309" precision="empty"/><line any_info="No Anys on this line!" content="        :param parameters: parameter dict" number="310" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="311" precision="empty"/><line any_info="No Anys on this line!" content="" number="312" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x8)" content="        for name, value in parameters.items():" number="313" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x1)&#10;Omitted Generics (x4)" content="            self.set_parameter(name, value)" number="314" precision="any"/><line any_info="No Anys on this line!" content="" number="315" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)" content="    def get_expected_parameters(self) -&gt; dict | str:" number="316" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="317" precision="empty"/><line any_info="No Anys on this line!" content="        Returns all the expected parameters as dictionary. Each parameter has the following types:" number="318" precision="empty"/><line any_info="No Anys on this line!" content="" number="319" precision="empty"/><line any_info="No Anys on this line!" content="        .. code-block:: python" number="320" precision="empty"/><line any_info="No Anys on this line!" content="" number="321" precision="empty"/><line any_info="No Anys on this line!" content="           result = {" number="322" precision="empty"/><line any_info="No Anys on this line!" content="               'name': {" number="323" precision="empty"/><line any_info="No Anys on this line!" content="                   'type': 'str | int | float | set | list | dict | type(None)'," number="324" precision="empty"/><line any_info="No Anys on this line!" content="                   'required': 'True | False'," number="325" precision="empty"/><line any_info="No Anys on this line!" content="                   'description': 'str'," number="326" precision="empty"/><line any_info="No Anys on this line!" content="                   'currentValue': 'str | int | float | set | list | dict | None'" number="327" precision="empty"/><line any_info="No Anys on this line!" content="               }" number="328" precision="empty"/><line any_info="No Anys on this line!" content="           }" number="329" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="330" precision="empty"/><line any_info="No Anys on this line!" content="" number="331" precision="empty"/><line any_info="No Anys on this line!" content="        expected_parameters = dict()" number="332" precision="precise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x11)&#10;Unimported (x3)" content="        [expected_parameters.update(param.to_dict(self))" number="333" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x4)&#10;Omitted Generics (x2)" content="         for param in self.__expected_parameters.values()]" number="334" precision="any"/><line any_info="No Anys on this line!" content="" number="335" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="        return expected_parameters" number="336" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="337" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="    def get_missing_required_parameters(self) -&gt; dict[str, set[str]]:" number="338" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="339" precision="empty"/><line any_info="No Anys on this line!" content="        This method returns the missing required parameters recursively" number="340" precision="empty"/><line any_info="No Anys on this line!" content="        for all nested instances, hence all parameters will be collected" number="341" precision="empty"/><line any_info="No Anys on this line!" content="        in the current scope." number="342" precision="empty"/><line any_info="No Anys on this line!" content="" number="343" precision="empty"/><line any_info="No Anys on this line!" content="        :return: dict, where key is the instance's full name and value is" number="344" precision="empty"/><line any_info="No Anys on this line!" content="                 a list of the names of the missing required parameters. If no missing" number="345" precision="empty"/><line any_info="No Anys on this line!" content="                 required parameters, then an empty dict will be returned" number="346" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="347" precision="empty"/><line any_info="No Anys on this line!" content="" number="348" precision="empty"/><line any_info="No Anys on this line!" content="        missing_required_parameters = dict()" number="349" precision="precise"/><line any_info="No Anys on this line!" content="" number="350" precision="empty"/><line any_info="No Anys on this line!" content="        # Calling for nested instances recursively" number="351" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x10)" content="        for instance in self.__nested_instances.values():" number="352" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="            missing_required_parameters.update(instance.get_missing_required_parameters())" number="353" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="354" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x4)&#10;Omitted Generics (x2)" content="        for expected_param in self.__expected_parameters.values():" number="355" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="            if expected_param.required:" number="356" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x7)&#10;Omitted Generics (x4)" content="                if (expected_param.name not in self.__parameters) or (self.__parameters[expected_param.name] is None):" number="357" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="                    if self.__full_name not in missing_required_parameters:" number="358" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x5)" content="                        missing_required_parameters[self.__full_name] = set()" number="359" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unimported (x2)" content="                    missing_required_parameters[self.__full_name].add(expected_param.name)" number="360" precision="any"/><line any_info="No Anys on this line!" content="" number="361" precision="empty"/><line any_info="No Anys on this line!" content="        return missing_required_parameters" number="362" precision="precise"/><line any_info="No Anys on this line!" content="" number="363" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="    def depends_on(self, instance: 'Instance') -&gt; None:" number="364" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="365" precision="empty"/><line any_info="No Anys on this line!" content="        Specify dependency instances of the actual instance. The following" number="366" precision="empty"/><line any_info="No Anys on this line!" content="        prerequisites shall be considered:" number="367" precision="empty"/><line any_info="No Anys on this line!" content="        - dependency must be the same specs type" number="368" precision="empty"/><line any_info="No Anys on this line!" content="        - dependency can be defined only in the same parent context" number="369" precision="empty"/><line any_info="No Anys on this line!" content="        The same parent context means that if there is an operatorA with plugin1" number="370" precision="empty"/><line any_info="No Anys on this line!" content="        and plugin2 and an operatorB with plugin3, then only plugin1 and plugin2" number="371" precision="empty"/><line any_info="No Anys on this line!" content="        can express dependencies to each other, since plugin3 is in another operator." number="372" precision="empty"/><line any_info="No Anys on this line!" content="" number="373" precision="empty"/><line any_info="No Anys on this line!" content="        :param instance: dependency instance" number="374" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="375" precision="empty"/><line any_info="No Anys on this line!" content="" number="376" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x5)&#10;Unannotated (x2)" content="        if not isinstance(instance, Instance):" number="377" precision="imprecise"/><line any_info="No Anys on this line!" content="            raise TypeError(f&quot;[{self.__full_name}] Invalid dependency type: {type(instance)}&quot;)" number="378" precision="unanalyzed"/><line any_info="No Anys on this line!" content="" number="379" precision="empty"/><line any_info="No Anys on this line!" content="        # Instance cannot depend on self" number="380" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="        if self is instance:" number="381" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="            raise AttributeError(f&quot;[{self.__full_name}] Invalid dependency. Instance cannot depend on itself. &quot;)" number="382" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="383" precision="empty"/><line any_info="No Anys on this line!" content="        # Makes no sense to express dependency between instances in different context" number="384" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x5)" content="        if (self.__context is None) or (instance.__context is None) or \" number="385" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x5)" content="                (self.__context is not instance.__context):" number="386" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="            raise AttributeError(f&quot;[{self.__full_name}] Invalid dependency. &quot;" number="387" precision="imprecise"/><line any_info="No Anys on this line!" content="                                 f&quot;Dependencies must have identical parent context.&quot;)" number="388" precision="empty"/><line any_info="No Anys on this line!" content="" number="389" precision="empty"/><line any_info="No Anys on this line!" content="        # Check circular dependency" number="390" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)" content="        if self in instance.__depends_on:" number="391" precision="imprecise"/><line any_info="No Anys on this line!" content="            raise RecursionError(f&quot;Circular dependency between detected: &quot;" number="392" precision="precise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="                                 f&quot;{self.__full_name} &lt;-&gt; {instance.__full_name} &quot;)" number="393" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="394" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x5)" content="        self.__depends_on.add(instance)" number="395" precision="any"/><line any_info="No Anys on this line!" content="" number="396" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unimported (x1)" content="    def get_dto(self) -&gt; InstanceDTO:" number="397" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="398" precision="empty"/><line any_info="No Anys on this line!" content="        Converts the instance information into the corresponding Data Transfer Object (DTO)" number="399" precision="empty"/><line any_info="No Anys on this line!" content="" number="400" precision="empty"/><line any_info="No Anys on this line!" content="        :return: DTO from instance" number="401" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="402" precision="empty"/><line any_info="No Anys on this line!" content="" number="403" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot; This is necessary to avoid the serialization of the extended dict's state and" number="404" precision="empty"/><line any_info="No Anys on this line!" content="            to prevent issues, if the parameters on the DTO are altered &quot;&quot;&quot;" number="405" precision="empty"/><line any_info="No Anys on this line!" content="        raw_parameters = dict()" number="406" precision="precise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x11)&#10;Unimported (x1)" content="        raw_parameters.update(self.__parameters)" number="407" precision="any"/><line any_info="No Anys on this line!" content="" number="408" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)&#10;Omitted Generics (x2)" content="        return InstanceDTO(name=self.__simple_name," number="409" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="                           parameters=raw_parameters," number="410" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x7)" content="                           dependsOn=[instance.get_simple_name() for instance in self.__depends_on]," number="411" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)&#10;Omitted Generics (x2)" content="                           spec=SpecDTO(name=self.__spec_name," number="412" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                                        types=[str(spec_class) for spec_class in" number="413" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)&#10;Omitted Generics (x3)" content="                                               remove_super_classes(self.__spec_classes)]," number="414" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)" content="                                        nestedInstanceType=None if self.__nested_instance_type is None" number="415" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)" content="                                        else str(self.__nested_instance_type)," number="416" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x6)" content="                                        expectedParameters=self.get_expected_parameters()," number="417" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)&#10;Unimported (x2)" content="                                        nestedInstances=[instance.get_dto() for instance in" number="418" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x8)" content="                                                         self.__nested_instances.values()]))" number="419" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="420" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)&#10;Unimported (x1)" content="    def update(self, source: InstanceDTO | dict | str) -&gt; None:" number="421" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="422" precision="empty"/><line any_info="No Anys on this line!" content="        This method allows to update certain attributes of the instance based on the" number="423" precision="empty"/><line any_info="No Anys on this line!" content="        provided DTO. All attributes can be updated here as well, for which a setter" number="424" precision="empty"/><line any_info="No Anys on this line!" content="        exists, in addition one can inject additional nested instances or update existing." number="425" precision="empty"/><line any_info="No Anys on this line!" content="" number="426" precision="empty"/><line any_info="No Anys on this line!" content="        :param source: json string, dict or DTO" number="427" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="428" precision="empty"/><line any_info="No Anys on this line!" content="" number="429" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unimported (x1)" content="        if isinstance(source, str):" number="430" precision="imprecise"/><line any_info="Any Types on this line: &#10;Unimported (x3)&#10;Explicit (x2)" content="            instance_dto = InstanceDTO(**yaml.safe_load(source))" number="431" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x20)&#10;Unimported (x1)" content="        elif isinstance(source, dict):" number="432" precision="imprecise"/><line any_info="Any Types on this line: &#10;Unimported (x3)" content="            instance_dto = InstanceDTO(**source)" number="433" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="        elif isinstance(source, InstanceDTO):" number="434" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="            instance_dto = source" number="435" precision="any"/><line any_info="No Anys on this line!" content="        else:" number="436" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x2)&#10;Unimported (x1)" content="            raise TypeError(f&quot;Invalid update source type: {type(source)}&quot;)" number="437" precision="any"/><line any_info="No Anys on this line!" content="" number="438" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x6)&#10;Omitted Generics (x2)" content="        if (instance_dto.name is not None) and (instance_dto.name != self.__simple_name):" number="439" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="            raise ValueError(f&quot;Mismatching instance name provided ({instance_dto.name}) and actual &quot;" number="440" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="                             f&quot;({self.__simple_name}) instance name. &quot;)" number="441" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="442" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="        if instance_dto.parameters is not None:" number="443" precision="any"/><line any_info="No Anys on this line!" content="            &quot;&quot;&quot; Note that at this point all the nested instances had to be created, hence we update" number="444" precision="empty"/><line any_info="No Anys on this line!" content="                the parameters of this instance before the nested instances' so the concept of" number="445" precision="empty"/><line any_info="No Anys on this line!" content="                proximity based precedence of parameter setting is honored. &quot;&quot;&quot;" number="446" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)&#10;Unimported (x2)" content="            self.set_parameters(instance_dto.parameters)" number="447" precision="any"/><line any_info="No Anys on this line!" content="" number="448" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="        if instance_dto.spec is not None:" number="449" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x8)&#10;Omitted Generics (x2)" content="            if (instance_dto.spec.name is not None) and (instance_dto.spec.name != self.__spec_name):" number="450" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)&#10;Unimported (x1)" content="                raise AttributeError(f&quot;[{self.__full_name}] Mismatching specs name. Loaded: {self.__spec_name}; &quot;" number="451" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                                     f&quot;Provided: {instance_dto.spec.name}&quot;)" number="452" precision="any"/><line any_info="No Anys on this line!" content="" number="453" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x6)" content="            if (instance_dto.spec.nestedInstances is not None) and (0 &lt; len(instance_dto.spec.nestedInstances)):" number="454" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)" content="                if self.__nested_instance_type is None:" number="455" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x6)&#10;Explicit (x2)" content="                    raise AttributeError(f&quot;[{self.get_full_name()}] No nested instance is expected for {type(self)}&quot;)" number="456" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="457" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x4)" content="                for nested_instance_dto in instance_dto.spec.nestedInstances:" number="458" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                    if nested_instance_dto.name is None:" number="459" precision="any"/><line any_info="No Anys on this line!" content="                        raise ValueError(&quot;Missing instance name&quot;)" number="460" precision="precise"/><line any_info="No Anys on this line!" content="" number="461" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)&#10;Omitted Generics (x4)" content="                    if nested_instance_dto.name not in self.__nested_instances:" number="462" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unimported (x1)" content="                        raise AttributeError(f&quot;[{self.get_full_name()}] Instance not found with name: &quot;" number="463" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x1)" content="                                             f&quot;{nested_instance_dto.name}&quot;)" number="464" precision="any"/><line any_info="No Anys on this line!" content="" number="465" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x8)&#10;Unimported (x4)" content="                    self.__nested_instances[nested_instance_dto.name].update(nested_instance_dto)" number="466" precision="any"/><line any_info="No Anys on this line!" content="" number="467" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="        if instance_dto.dependsOn is not None:" number="468" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x3)" content="            for instance_name in instance_dto.dependsOn:" number="469" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x1)&#10;Omitted Generics (x4)" content="                if instance_name not in self.__context.__nested_instances:" number="470" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unimported (x1)" content="                    raise AttributeError(f&quot;[{self.__full_name}] Instance not found in context &quot;" number="471" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="                                         f&quot;'{self.__context.__full_name}': {instance_name}&quot;)" number="472" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="473" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x8)&#10;Unimported (x1)" content="                self.depends_on(self.__context.__nested_instances[instance_name])" number="474" precision="any"/><line any_info="No Anys on this line!" content="" number="475" precision="empty"/><line any_info="No Anys on this line!" content="    # ========= protected methods ==========" number="476" precision="empty"/><line any_info="No Anys on this line!" content="" number="477" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unannotated (x2)" content="    def __on_init_finished__(self, *args, **kwargs) -&gt; None:" number="478" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="479" precision="empty"/><line any_info="No Anys on this line!" content="        This method can be overridden to implement logic that shall be executed after" number="480" precision="empty"/><line any_info="No Anys on this line!" content="        the Instance's __init__ has been finished." number="481" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="482" precision="empty"/><line any_info="No Anys on this line!" content="" number="483" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x4)" content="        instance_dto = kwargs[&quot;from_dto&quot;] if &quot;from_dto&quot; in kwargs else None" number="484" precision="any"/><line any_info="No Anys on this line!" content="" number="485" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x1)" content="        if instance_dto is not None:" number="486" precision="any"/><line any_info="No Anys on this line!" content="            # Creating not existing nested instances" number="487" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x2)" content="            if instance_dto.spec is not None:" number="488" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x8)&#10;Omitted Generics (x2)" content="                if (instance_dto.spec.name is not None) and (instance_dto.spec.name != self.__spec_name):" number="489" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)&#10;Unannotated (x1)" content="                    raise AttributeError(f&quot;[{self.__full_name}] Mismatching specs name: {self.__spec_name}; &quot;" number="490" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)" content="                                         f&quot;Expected: {instance_dto.spec.name}&quot;)" number="491" precision="any"/><line any_info="No Anys on this line!" content="" number="492" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x6)" content="                if (instance_dto.spec.nestedInstances is not None) and (0 &lt; len(instance_dto.spec.nestedInstances)):" number="493" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)" content="                    if self.__nested_instance_type is None:" number="494" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)" content="                        raise AttributeError(f&quot;[{self.__full_name}] &quot;" number="495" precision="imprecise"/><line any_info="Any Types on this line: &#10;Explicit (x2)&#10;Omitted Generics (x2)" content="                                             f&quot;No nested instance is expected for {type(self)}&quot;)" number="496" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="497" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x4)" content="                    for nested_instance_dto in instance_dto.spec.nestedInstances:" number="498" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)" content="                        if nested_instance_dto.name is None:" number="499" precision="any"/><line any_info="No Anys on this line!" content="                            raise ValueError(&quot;Missing instance name&quot;)" number="500" precision="precise"/><line any_info="No Anys on this line!" content="" number="501" precision="empty"/><line any_info="No Anys on this line!" content="                        # First we need to make sure that all instances are created." number="502" precision="empty"/><line any_info="No Anys on this line!" content="                        # This has to happen before updating the instances, since if" number="503" precision="empty"/><line any_info="No Anys on this line!" content="                        # an already existing instance refers to a not yet existing" number="504" precision="empty"/><line any_info="No Anys on this line!" content="                        # then error will arise." number="505" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x2)&#10;Omitted Generics (x4)" content="                        if nested_instance_dto.name not in self.__nested_instances:" number="506" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x6)&#10;Omitted Generics (x2)" content="                            nested_instance_reference = self.__reference.__nested_instances[nested_instance_dto.name] \" number="507" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)&#10;Omitted Generics (x2)" content="                                if self.__reference is not None else None" number="508" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x7)&#10;Unimported (x1)&#10;Unannotated (x2)" content="                            new_nested_instance = self.__nested_instance_type.create_from_dto(" number="509" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)&#10;Omitted Generics (x2)" content="                                nested_instance_dto, context=self, reference=nested_instance_reference," number="510" precision="any"/><line any_info="No Anys on this line!" content="                                mock_nonexistent=True, disable_auto_update=True)" number="511" precision="precise"/><line any_info="No Anys on this line!" content="" number="512" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x5)" content="                            if not isinstance(new_nested_instance, self.__nested_instance_type):" number="513" precision="imprecise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="                                raise AttributeError(f&quot;[{new_nested_instance.get_full_name()}] &quot;" number="514" precision="imprecise"/><line any_info="No Anys on this line!" content="                                                     f&quot;Mismatching nested instance type. Expected: &quot;" number="515" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="                                                     f&quot;{self.__nested_instance_type}&quot;)" number="516" precision="imprecise"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x6)" content="                            self.__setattr__(new_nested_instance.__simple_name, new_nested_instance)" number="517" precision="any"/><line any_info="No Anys on this line!" content="" number="518" precision="empty"/><line any_info="No Anys on this line!" content="    # ========= internal methods ==========" number="519" precision="empty"/><line any_info="No Anys on this line!" content="" number="520" precision="empty"/><line any_info="No Anys on this line!" content="    def __setattr__(self, name, value):" number="521" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="522" precision="empty"/><line any_info="No Anys on this line!" content="        Overridden method to allow the discovery, registration and linking of" number="523" precision="empty"/><line any_info="No Anys on this line!" content="        nested objects. It checks, whether the value is an instance of the" number="524" precision="empty"/><line any_info="No Anys on this line!" content="        expected nested instance type, then it retrieves the instance's" number="525" precision="empty"/><line any_info="No Anys on this line!" content="        simple name if not given, and then it links the both the parent and" number="526" precision="empty"/><line any_info="No Anys on this line!" content="        the nested context to each other" number="527" precision="empty"/><line any_info="No Anys on this line!" content="" number="528" precision="empty"/><line any_info="No Anys on this line!" content="        :param name: name of the variable" number="529" precision="empty"/><line any_info="No Anys on this line!" content="        :param value: value of the variable" number="530" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="531" precision="empty"/><line any_info="No Anys on this line!" content="" number="532" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x1)" content="        if isinstance(value, InterceptedInstance):" number="533" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)" content="            final_instance_name = value.instance_name if value.instance_name is not None else name" number="534" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x5)&#10;Omitted Generics (x2)" content="            nested_instance_reference = self.__reference.__nested_instances[final_instance_name] \" number="535" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)&#10;Omitted Generics (x2)" content="                if self.__reference is not None else None" number="536" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)&#10;Omitted Generics (x2)" content="            if (self.__nested_instance_type is not None) and \" number="537" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x3)&#10;Omitted Generics (x2)" content="                    (issubclass(value.context_class, self.__nested_instance_type)):" number="538" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x5)&#10;Omitted Generics (x2)" content="                instance = value.context_class(final_instance_name, context=self, reference=nested_instance_reference," number="539" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)" content="                                               *value.args,  **value.kwargs)" number="540" precision="any"/><line any_info="No Anys on this line!" content="            else:" number="541" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x5)" content="                instance = value.context_class(final_instance_name, context=None, reference=nested_instance_reference," number="542" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)" content="                                               *value.args, **value.kwargs)" number="543" precision="any"/><line any_info="No Anys on this line!" content="        else:" number="544" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x2)" content="            instance = value" number="545" precision="any"/><line any_info="No Anys on this line!" content="" number="546" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x2)" content="        object.__setattr__(self, name, instance)" number="547" precision="any"/><line any_info="No Anys on this line!" content="" number="548" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x11)&#10;Omitted Generics (x6)" content="        if hasattr(self, f&quot;_{Instance.__name__}__nested_instance_type&quot;) and \" number="549" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)&#10;Omitted Generics (x2)" content="                (self.__nested_instance_type is not None) and \" number="550" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x3)&#10;Omitted Generics (x2)" content="                isinstance(instance, self.__nested_instance_type) and \" number="551" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)&#10;Omitted Generics (x2)" content="                (instance is not self.__context):" number="552" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x2)" content="            if instance.get_simple_name() in self.__nested_instances:" number="553" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x8)" content="                raise AttributeError(f&quot;Instance with name already declared: {instance.get_simple_name()}&quot;)" number="554" precision="any"/><line any_info="No Anys on this line!" content="" number="555" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x5)&#10;Omitted Generics (x2)" content="            self.__nested_instances[instance.get_simple_name()] = instance" number="556" precision="any"/><line any_info="No Anys on this line!" content="" number="557" precision="empty"/><line any_info="No Anys on this line!" content="    def __eq__(self, other):" number="558" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unannotated (x1)" content="        if self is other:" number="559" precision="any"/><line any_info="No Anys on this line!" content="            return True" number="560" precision="any"/><line any_info="No Anys on this line!" content="" number="561" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x9)&#10;Explicit (x2)&#10;Omitted Generics (x2)" content="        return isinstance(other, type(self)) and \" number="562" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x2)" content="            (self.__simple_name == other.__simple_name) and \" number="563" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x2)" content="            (self.__parameters == other.__parameters) and \" number="564" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x2)" content="            (self.__depends_on == other.__depends_on) and \" number="565" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x2)" content="            (self.__nested_instances == other.__nested_instances) and \" number="566" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x2)" content="            (self.__expected_parameters == other.__expected_parameters) and \" number="567" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Omitted Generics (x2)" content="            (self.__spec_name == other.__spec_name)" number="568" precision="any"/><line any_info="No Anys on this line!" content="" number="569" precision="empty"/><line any_info="No Anys on this line!" content="    def __str__(self):" number="570" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)&#10;Explicit (x4)&#10;Unimported (x1)&#10;Omitted Generics (x2)" content="        return yaml.safe_dump(convert_to_dict(self.get_dto()), default_flow_style=False)" number="571" precision="any"/><line any_info="No Anys on this line!" content="" number="572" precision="empty"/><line any_info="No Anys on this line!" content="    def __hash__(self):" number="573" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x3)&#10;Omitted Generics (x4)" content="        return hash((self.__full_name, self.__spec_name))" number="574" precision="any"/><line any_info="No Anys on this line!" content="" number="575" precision="empty"/><line any_info="No Anys on this line!" content="    def __getattr__(self, name):" number="576" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x3)&#10;Omitted Generics (x2)" content="        return self.__getattribute__(name)" number="577" precision="any"/><line any_info="No Anys on this line!" content="" number="578" precision="empty"/><line any_info="No Anys on this line!" content="    # ================= static methods =====================" number="579" precision="empty"/><line any_info="No Anys on this line!" content="" number="580" precision="empty"/><line any_info="No Anys on this line!" content="    @staticmethod" number="581" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x1)&#10;Unannotated (x2)&#10;Omitted Generics (x1)" content="    def create_from_dto(instance_dto: InstanceDTO, *args, **kwargs) -&gt; 'Instance':" number="582" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="583" precision="empty"/><line any_info="No Anys on this line!" content="        Creates an instance object from the DTO representation. It is capable" number="584" precision="empty"/><line any_info="No Anys on this line!" content="        to retrieve and load specified classes and to update created instances" number="585" precision="empty"/><line any_info="No Anys on this line!" content="        according to the DTO." number="586" precision="empty"/><line any_info="No Anys on this line!" content="" number="587" precision="empty"/><line any_info="No Anys on this line!" content="        :param instance_dto: instance DTO" number="588" precision="empty"/><line any_info="No Anys on this line!" content="        :return: instance object specified by the DTO" number="589" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="590" precision="empty"/><line any_info="No Anys on this line!" content="" number="591" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="        if not isinstance(instance_dto, InstanceDTO):" number="592" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x2)&#10;Unimported (x1)" content="            raise TypeError(f&quot;Invalid instance DTO type: {type(instance_dto)}&quot;)" number="593" precision="any"/><line any_info="No Anys on this line!" content="" number="594" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="        if instance_dto.name is None:" number="595" precision="any"/><line any_info="No Anys on this line!" content="            raise ValueError(&quot;Missing instance name&quot;)" number="596" precision="precise"/><line any_info="No Anys on this line!" content="" number="597" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x5)" content="        if (instance_dto.spec is None) or (instance_dto.spec.name is None):" number="598" precision="any"/><line any_info="No Anys on this line!" content="            raise AttributeError(&quot;Invalid or missing 'specs' definition&quot;)" number="599" precision="precise"/><line any_info="No Anys on this line!" content="" number="600" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x6)" content="        if 0 &gt; instance_dto.spec.name.find(&quot;:&quot;):" number="601" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x3)" content="            raise ValueError(f&quot;Class loading error. Invalid class specifier: {instance_dto.spec.name}; &quot;" number="602" precision="any"/><line any_info="No Anys on this line!" content="                             f&quot;Class specifier must be composed of [PACKAGE_NAME.]MODULE_NAME:CLASS_NAME[.CLASS_NAME+]&quot;)" number="603" precision="empty"/><line any_info="No Anys on this line!" content="" number="604" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x3)" content="        if instance_dto.spec.location is not None:" number="605" precision="any"/><line any_info="No Anys on this line!" content="            # TODO - remote retrieval shall be implemented here" number="606" precision="empty"/><line any_info="No Anys on this line!" content="            raise NotImplementedError(&quot;Location based retrieval not yet implemented&quot;)" number="607" precision="precise"/><line any_info="No Anys on this line!" content="" number="608" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x5)" content="        mock_nonexistent = (&quot;mock_nonexistent&quot; in kwargs) and (kwargs[&quot;mock_nonexistent&quot;])" number="609" precision="any"/><line any_info="No Anys on this line!" content="" number="610" precision="empty"/><line any_info="No Anys on this line!" content="        try:" number="611" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)" content="            instance: Instance = \" number="612" precision="imprecise"/><line any_info="Any Types on this line: &#10;Unimported (x10)" content="                load_class_by_name(instance_dto.spec.name.replace(&quot;:&quot;, &quot;.&quot;))(instance_dto.name," number="613" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x1)" content="                                                                             from_dto=instance_dto," number="614" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)" content="                                                                             *args, **kwargs)" number="615" precision="imprecise"/><line any_info="No Anys on this line!" content="        except (ModuleNotFoundError, AttributeError) as e:" number="616" precision="precise"/><line any_info="Any Types on this line: &#10;Unannotated (x1)" content="            if mock_nonexistent:" number="617" precision="imprecise"/><line any_info="Any Types on this line: &#10;Unimported (x6)" content="                if (instance_dto.spec.types is None) or (0 == len(instance_dto.spec.types)):" number="618" precision="any"/><line any_info="No Anys on this line!" content="                    raise AttributeError(&quot;Missing type specification: instance.spec.types: List[Str]&quot;)" number="619" precision="precise"/><line any_info="No Anys on this line!" content="" number="620" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="                base_classes = set()" number="621" precision="precise"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="                abstract_methods = set()" number="622" precision="precise"/><line any_info="No Anys on this line!" content="" number="623" precision="empty"/><line any_info="No Anys on this line!" content="                # Retrieve and check base classes specified in spec.types" number="624" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x4)" content="                for class_name in instance_dto.spec.types:" number="625" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x4)" content="                    loaded_class = load_class_by_name(class_name)" number="626" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x1)&#10;Omitted Generics (x4)&#10;Unannotated (x2)" content="                    if not issubclass(loaded_class, (Instance, RegisteredInterface)):" number="627" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x1)&#10;Omitted Generics (x4)&#10;Unannotated (x2)" content="                        raise TypeError(f&quot;Invalid spec type: {loaded_class}. Expected subclass of {Instance}&quot;)" number="628" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x3)" content="                    base_classes.add(loaded_class)" number="629" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x2)&#10;Unimported (x2)" content="                    abstract_methods.update(loaded_class.__abstractmethods__)" number="630" precision="any"/><line any_info="No Anys on this line!" content="" number="631" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x4)" content="                nested_instance_type = None if instance_dto.spec.nestedInstanceType is None \" number="632" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x5)" content="                    else load_class_by_name(instance_dto.spec.nestedInstanceType)" number="633" precision="any"/><line any_info="No Anys on this line!" content="" number="634" precision="empty"/><line any_info="No Anys on this line!" content="                # Creating dummy implementation of abstract methods" number="635" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x4)" content="                class_body = {abstract_method: lambda: None for abstract_method in abstract_methods}" number="636" precision="any"/><line any_info="No Anys on this line!" content="" number="637" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x6)" content="                module_and_name = instance_dto.spec.name.split(&quot;:&quot;)" number="638" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)&#10;Omitted Generics (x1)" content="                class_body[&quot;__module__&quot;] = module_and_name[0]" number="639" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x1)" content="                class_body[&quot;mocked&quot;] = True" number="640" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="641" precision="empty"/><line any_info="No Anys on this line!" content="                # Create new type with name and bases" number="642" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x2)&#10;Unimported (x2)" content="                instance_type = types.new_class(module_and_name[1]," number="643" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x3)" content="                                                tuple(remove_super_classes(base_classes))," number="644" precision="any"/><line any_info="Any Types on this line: &#10;Explicit (x6)&#10;Omitted Generics (x1)" content="                                                {}, lambda ns: ns.update(class_body))" number="645" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="646" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x2)&#10;Error (x1)" content="                if &quot;nested_instance_type&quot; in inspect.signature(instance_type.__init__).parameters:" number="647" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x1)&#10;Explicit (x1)&#10;Unimported (x2)&#10;Error (x1)" content="                    instance: Instance = instance_type(instance_dto.name," number="648" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x1)" content="                                                       nested_instance_type=nested_instance_type," number="649" precision="imprecise"/><line any_info="Any Types on this line: &#10;Unannotated (x2)&#10;Unimported (x1)" content="                                                       from_dto=instance_dto, *args, **kwargs)" number="650" precision="any"/><line any_info="No Anys on this line!" content="                else:" number="651" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x1)&#10;Explicit (x1)&#10;Unimported (x2)&#10;Error (x1)" content="                    instance: Instance = instance_type(instance_dto.name," number="652" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)&#10;Unimported (x1)" content="                                                       from_dto=instance_dto, *args, **kwargs)" number="653" precision="any"/><line any_info="No Anys on this line!" content="" number="654" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x3)" content="                print(f&quot;[WARNING] Mock instance created of spec '{instance_dto.spec.name}' for &quot;" number="655" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x1)" content="                      f&quot;[{instance.get_full_name()}]. Reason: {e}&quot;, file=sys.stderr)" number="656" precision="imprecise"/><line any_info="No Anys on this line!" content="            else:" number="657" precision="empty"/><line any_info="No Anys on this line!" content="                raise" number="658" precision="empty"/><line any_info="No Anys on this line!" content="" number="659" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x3)" content="        if (&quot;disable_auto_update&quot; not in kwargs) or (not kwargs[&quot;disable_auto_update&quot;]):" number="660" precision="any"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)&#10;Unimported (x2)" content="            instance.update(instance_dto)" number="661" precision="any"/><line any_info="No Anys on this line!" content="" number="662" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x1)" content="        return instance" number="663" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="664" precision="empty"/><line any_info="No Anys on this line!" content="    @staticmethod" number="665" precision="empty"/><line any_info="Any Types on this line: &#10;Unannotated (x3)&#10;Omitted Generics (x1)" content="    def create_from_string(source, *args, **kwargs) -&gt; 'Instance':" number="666" precision="any"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="667" precision="empty"/><line any_info="No Anys on this line!" content="        Helper method to provide the functionality to create an instance from" number="668" precision="empty"/><line any_info="No Anys on this line!" content="        a json model specified either as string or as dict." number="669" precision="empty"/><line any_info="No Anys on this line!" content="" number="670" precision="empty"/><line any_info="No Anys on this line!" content="        :param source: model as string" number="671" precision="empty"/><line any_info="No Anys on this line!" content="        :return: instance object specified by the DTO" number="672" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="673" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x6)&#10;Unimported (x3)&#10;Unannotated (x7)&#10;Explicit (x2)" content="        return Instance.create_from_dto(InstanceDTO(**yaml.safe_load(source)), *args, **kwargs)" number="674" precision="any"/><line any_info="No Anys on this line!" content="" number="675" precision="empty"/><line any_info="No Anys on this line!" content="" number="676" precision="empty"/><line any_info="No Anys on this line!" content="class InstanceGroup(ABC):" number="677" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="678" precision="empty"/><line any_info="No Anys on this line!" content="    This class provides methods to access instance group related information. It can be" number="679" precision="empty"/><line any_info="No Anys on this line!" content="    implemented on different instance level, since a group might have different meaning" number="680" precision="empty"/><line any_info="No Anys on this line!" content="    on top level and on nested level." number="681" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="682" precision="empty"/><line any_info="No Anys on this line!" content="" number="683" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="684" precision="empty"/><line any_info="No Anys on this line!" content="    def get_group_size(self) -&gt; int:" number="685" precision="precise"/><line any_info="No Anys on this line!" content="        pass" number="686" precision="precise"/><line any_info="No Anys on this line!" content="" number="687" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="688" precision="empty"/><line any_info="No Anys on this line!" content="    def get_group_index(self) -&gt; int:" number="689" precision="precise"/><line any_info="No Anys on this line!" content="        pass" number="690" precision="precise"/><line any_info="No Anys on this line!" content="" number="691" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="692" precision="empty"/><line any_info="No Anys on this line!" content="    def get_group_name(self) -&gt; Optional[str]:" number="693" precision="precise"/><line any_info="No Anys on this line!" content="        pass" number="694" precision="precise"/><line any_info="No Anys on this line!" content="" number="695" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="696" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x1)" content="    def get_group_principal(self) -&gt; Optional['Instance']:" number="697" precision="imprecise"/><line any_info="No Anys on this line!" content="        pass" number="698" precision="precise"/><line any_info="No Anys on this line!" content="" number="699" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="700" precision="empty"/><line any_info="No Anys on this line!" content="    def is_principal(self) -&gt; bool:" number="701" precision="precise"/><line any_info="No Anys on this line!" content="        pass" number="702" precision="precise"/></mypy-report-file>