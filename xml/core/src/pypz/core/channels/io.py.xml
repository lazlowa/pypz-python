<?xml-stylesheet type="text/xsl" href="../../../../../../mypy-html.xslt"?><mypy-report-file name="core\src\pypz\core\channels\io.py" module="core.src.pypz.core.channels.io"><line any_info="No Anys on this line!" content="# =============================================================================" number="1" precision="empty"/><line any_info="No Anys on this line!" content="# Copyright (c) 2024 by Laszlo Anka. All rights reserved." number="2" precision="empty"/><line any_info="No Anys on this line!" content="#" number="3" precision="empty"/><line any_info="No Anys on this line!" content="# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);" number="4" precision="empty"/><line any_info="No Anys on this line!" content="# you may not use this file except in compliance with the License." number="5" precision="empty"/><line any_info="No Anys on this line!" content="# You may obtain a copy of the License at" number="6" precision="empty"/><line any_info="No Anys on this line!" content="#" number="7" precision="empty"/><line any_info="No Anys on this line!" content="#     http://www.apache.org/licenses/LICENSE-2.0" number="8" precision="empty"/><line any_info="No Anys on this line!" content="#" number="9" precision="empty"/><line any_info="No Anys on this line!" content="# Unless required by applicable law or agreed to in writing, software" number="10" precision="empty"/><line any_info="No Anys on this line!" content="# distributed under the License is distributed on an &quot;AS IS&quot; BASIS," number="11" precision="empty"/><line any_info="No Anys on this line!" content="# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied." number="12" precision="empty"/><line any_info="No Anys on this line!" content="# See the License for the specific language governing permissions and" number="13" precision="empty"/><line any_info="No Anys on this line!" content="# limitations under the License." number="14" precision="empty"/><line any_info="No Anys on this line!" content="# =============================================================================" number="15" precision="empty"/><line any_info="No Anys on this line!" content="import concurrent.futures" number="16" precision="precise"/><line any_info="No Anys on this line!" content="from typing import Any, TYPE_CHECKING, Optional" number="17" precision="precise"/><line any_info="No Anys on this line!" content="from abc import abstractmethod" number="18" precision="precise"/><line any_info="No Anys on this line!" content="import threading" number="19" precision="precise"/><line any_info="No Anys on this line!" content="" number="20" precision="empty"/><line any_info="No Anys on this line!" content="from pypz.core.channels.base import ChannelBase, ChannelMetric" number="21" precision="any"/><line any_info="No Anys on this line!" content="from pypz.core.channels.status import ChannelStatus" number="22" precision="any"/><line any_info="No Anys on this line!" content="from pypz.core.commons.utils import current_time_millis" number="23" precision="any"/><line any_info="No Anys on this line!" content="" number="24" precision="empty"/><line any_info="No Anys on this line!" content="if TYPE_CHECKING:" number="25" precision="precise"/><line any_info="No Anys on this line!" content="    from pypz.core.specs.plugin import InputPortPlugin, OutputPortPlugin" number="26" precision="any"/><line any_info="No Anys on this line!" content="" number="27" precision="empty"/><line any_info="No Anys on this line!" content="" number="28" precision="empty"/><line any_info="No Anys on this line!" content="class ChannelReader(ChannelBase):" number="29" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="30" precision="empty"/><line any_info="No Anys on this line!" content="    This class is the base of the input channel classes." number="31" precision="empty"/><line any_info="No Anys on this line!" content="    The idea is that the class provides some core, protected abstract methods, which shall be implemented by" number="32" precision="empty"/><line any_info="No Anys on this line!" content="    the developer. These implementations then will be invoked by invoker methods. This makes sure that additional" number="33" precision="empty"/><line any_info="No Anys on this line!" content="    necessary logic will be performed along the implemented." number="34" precision="empty"/><line any_info="No Anys on this line!" content="" number="35" precision="empty"/><line any_info="No Anys on this line!" content="    :param channel_name: name of the channel" number="36" precision="empty"/><line any_info="No Anys on this line!" content="    :param context: the :class:`PortPlugin &lt;pypz.core.specs.plugin.PortPlugin&gt;`, which operates this channel" number="37" precision="empty"/><line any_info="No Anys on this line!" content="    :param executor: an external ThreadPoolExecutor, if not provided, on will be created internally" number="38" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="39" precision="empty"/><line any_info="No Anys on this line!" content="" number="40" precision="empty"/><line any_info="No Anys on this line!" content="    # ======================= static fields =======================" number="41" precision="empty"/><line any_info="No Anys on this line!" content="" number="42" precision="empty"/><line any_info="No Anys on this line!" content="    NotInitialized = -1" number="43" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="44" precision="empty"/><line any_info="No Anys on this line!" content="    Some helper static to init or identify if offset is not initialized" number="45" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="46" precision="empty"/><line any_info="No Anys on this line!" content="" number="47" precision="empty"/><line any_info="No Anys on this line!" content="    MetricsBufferLength = 10" number="48" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="49" precision="empty"/><line any_info="No Anys on this line!" content="    This variable specifies the length of the metric buffer and so the averaging window" number="50" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="51" precision="empty"/><line any_info="No Anys on this line!" content="" number="52" precision="empty"/><line any_info="No Anys on this line!" content="    # ======================= Ctor =======================" number="53" precision="empty"/><line any_info="No Anys on this line!" content="" number="54" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x1)&#10;Unannotated (x1)" content="    def __init__(self, channel_name: str," number="55" precision="any"/><line any_info="No Anys on this line!" content="                 context: 'InputPortPlugin'," number="56" precision="empty"/><line any_info="No Anys on this line!" content="                 executor: Optional[concurrent.futures.ThreadPoolExecutor] = None," number="57" precision="precise"/><line any_info="No Anys on this line!" content="                 **kwargs):" number="58" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x1)&#10;Unannotated (x1)" content="        super().__init__(channel_name, context, executor, **kwargs)" number="59" precision="any"/><line any_info="No Anys on this line!" content="" number="60" precision="empty"/><line any_info="No Anys on this line!" content="        self._read_record_count: int = 0" number="61" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="62" precision="empty"/><line any_info="No Anys on this line!" content="        Counter for how many records have been read by this channel. Note that this value can differ from the" number="63" precision="empty"/><line any_info="No Anys on this line!" content="        offset value in case of crash-restart. Still the framework maintains the difference between this value" number="64" precision="empty"/><line any_info="No Anys on this line!" content="        and the loaded offset and will compensate the framework calculated offset by that difference." number="65" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="66" precision="empty"/><line any_info="No Anys on this line!" content="" number="67" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x1)&#10;Unannotated (x1)" content="        self._read_record_offset: int = ChannelReader.NotInitialized" number="68" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="69" precision="empty"/><line any_info="No Anys on this line!" content="        The actual write offset of the read records. Eg. if 10 records have been read and provided to the plugin" number="70" precision="empty"/><line any_info="No Anys on this line!" content="        then the offset is 10. Note that this might differ from the m_inputRecordCount_i64 in case of crash-restart." number="71" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="72" precision="empty"/><line any_info="No Anys on this line!" content="" number="73" precision="empty"/><line any_info="No Anys on this line!" content="        self._initial_input_record_offset: int = 0" number="74" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="75" precision="empty"/><line any_info="No Anys on this line!" content="        This is variable stores the initial offset, which can be different than 0 in case of crash-restart. In this" number="76" precision="empty"/><line any_info="No Anys on this line!" content="        case this value is actually the difference by which the framework calculated offset shall be compensated." number="77" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="78" precision="empty"/><line any_info="No Anys on this line!" content="" number="79" precision="empty"/><line any_info="No Anys on this line!" content="        self._last_offset_committed: int = 0" number="80" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="81" precision="empty"/><line any_info="No Anys on this line!" content="        This value tracks the last committed offset. The main use-case of this variable is to prevent offset commit" number="82" precision="empty"/><line any_info="No Anys on this line!" content="        if the new offset equals the last committed." number="83" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="84" precision="empty"/><line any_info="No Anys on this line!" content="" number="85" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x3)&#10;Omitted Generics (x3)" content="        self._metrics_buffer: list[ChannelMetric] = list()" number="86" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="87" precision="empty"/><line any_info="No Anys on this line!" content="        This list holds metric elements, however the only purpose is to be aware of the first" number="88" precision="empty"/><line any_info="No Anys on this line!" content="        element to discard like in a circular buffer" number="89" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="90" precision="empty"/><line any_info="No Anys on this line!" content="" number="91" precision="empty"/><line any_info="No Anys on this line!" content="        self._aggregated_time_between_reads: int = 0" number="92" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="93" precision="empty"/><line any_info="No Anys on this line!" content="        Metric value to store the summed up times between reads" number="94" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="95" precision="empty"/><line any_info="No Anys on this line!" content="" number="96" precision="empty"/><line any_info="No Anys on this line!" content="        self._aggregated_record_count: int = 0" number="97" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="98" precision="empty"/><line any_info="No Anys on this line!" content="        Metric value to store the summed up record count" number="99" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="100" precision="empty"/><line any_info="No Anys on this line!" content="" number="101" precision="empty"/><line any_info="No Anys on this line!" content="        self._current_read_timestamp: int = 0" number="102" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="103" precision="empty"/><line any_info="No Anys on this line!" content="        Stores the timestamp of the most current read to be able to calculate elapsed time" number="104" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="105" precision="empty"/><line any_info="No Anys on this line!" content="" number="106" precision="empty"/><line any_info="No Anys on this line!" content="        self._current_read_record_count: int = 0" number="107" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="108" precision="empty"/><line any_info="No Anys on this line!" content="        Stores the record count of the most current read" number="109" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="110" precision="empty"/><line any_info="No Anys on this line!" content="" number="111" precision="empty"/><line any_info="No Anys on this line!" content="        self._status_sender_lock = threading.Lock()" number="112" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="113" precision="empty"/><line any_info="No Anys on this line!" content="        This lock is used to prevent concurrent modification of metrics" number="114" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="115" precision="empty"/><line any_info="No Anys on this line!" content="" number="116" precision="empty"/><line any_info="No Anys on this line!" content="    # ======================= Abstract methods =======================" number="117" precision="empty"/><line any_info="No Anys on this line!" content="" number="118" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="119" precision="empty"/><line any_info="No Anys on this line!" content="    def _load_input_record_offset(self) -&gt; int:" number="120" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="121" precision="empty"/><line any_info="No Anys on this line!" content="        This method shall implement the logic to retrieve stored read offset from the underlying technology. This" number="122" precision="empty"/><line any_info="No Anys on this line!" content="        can be arbitrary, but the method shall return the stored offset." number="123" precision="empty"/><line any_info="No Anys on this line!" content="" number="124" precision="empty"/><line any_info="No Anys on this line!" content="        :return: stored offset" number="125" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="126" precision="empty"/><line any_info="No Anys on this line!" content="        pass" number="127" precision="precise"/><line any_info="No Anys on this line!" content="" number="128" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="129" precision="empty"/><line any_info="No Anys on this line!" content="    def has_records(self) -&gt; bool:" number="130" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="131" precision="empty"/><line any_info="No Anys on this line!" content="        This method shall implement the logic to check, if the reader can still read records." number="132" precision="empty"/><line any_info="No Anys on this line!" content="" number="133" precision="empty"/><line any_info="No Anys on this line!" content="        :return: True if channel has still records, False if not" number="134" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="135" precision="empty"/><line any_info="No Anys on this line!" content="        return True" number="136" precision="precise"/><line any_info="No Anys on this line!" content="" number="137" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="138" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x1)" content="    def _read_records(self) -&gt; list[Any]:" number="139" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="140" precision="empty"/><line any_info="No Anys on this line!" content="        This method shall implement the logic to read records from the input channel. An ArrayList of records is" number="141" precision="empty"/><line any_info="No Anys on this line!" content="        expected." number="142" precision="empty"/><line any_info="No Anys on this line!" content="" number="143" precision="empty"/><line any_info="No Anys on this line!" content="        :return: list of records OR empty ArrayList if no records read. Null is not accepted." number="144" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="145" precision="empty"/><line any_info="No Anys on this line!" content="        pass" number="146" precision="precise"/><line any_info="No Anys on this line!" content="" number="147" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="148" precision="empty"/><line any_info="No Anys on this line!" content="    def _commit_offset(self, offset: int) -&gt; None:" number="149" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="150" precision="empty"/><line any_info="No Anys on this line!" content="        This method shall implement the logic that commits the provided offset using the underlying technology." number="151" precision="empty"/><line any_info="No Anys on this line!" content="" number="152" precision="empty"/><line any_info="No Anys on this line!" content="        :param offset: provided offset to commit" number="153" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="154" precision="empty"/><line any_info="No Anys on this line!" content="        pass" number="155" precision="precise"/><line any_info="No Anys on this line!" content="" number="156" precision="empty"/><line any_info="No Anys on this line!" content="    # ======================= Getter/setter/invoker methods =======================" number="157" precision="empty"/><line any_info="No Anys on this line!" content="" number="158" precision="empty"/><line any_info="No Anys on this line!" content="    def get_read_record_count(self) -&gt; int:" number="159" precision="precise"/><line any_info="No Anys on this line!" content="        return self._read_record_count" number="160" precision="precise"/><line any_info="No Anys on this line!" content="" number="161" precision="empty"/><line any_info="No Anys on this line!" content="    def get_read_record_offset(self) -&gt; int:" number="162" precision="precise"/><line any_info="No Anys on this line!" content="        return self._read_record_offset" number="163" precision="precise"/><line any_info="No Anys on this line!" content="" number="164" precision="empty"/><line any_info="No Anys on this line!" content="    def set_initial_record_offset(self, initial_record_offset: int) -&gt; None:" number="165" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="166" precision="empty"/><line any_info="No Anys on this line!" content="        This method initializes the internal variables" number="167" precision="empty"/><line any_info="No Anys on this line!" content="" number="168" precision="empty"/><line any_info="No Anys on this line!" content="        :param initial_record_offset: value to be initialized to" number="169" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="170" precision="empty"/><line any_info="No Anys on this line!" content="" number="171" precision="empty"/><line any_info="No Anys on this line!" content="        self._initial_input_record_offset = initial_record_offset" number="172" precision="precise"/><line any_info="No Anys on this line!" content="        self._last_offset_committed = initial_record_offset" number="173" precision="precise"/><line any_info="No Anys on this line!" content="        self._read_record_offset = initial_record_offset" number="174" precision="precise"/><line any_info="No Anys on this line!" content="" number="175" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="176" precision="empty"/><line any_info="No Anys on this line!" content="    This method sets the initial values of the internal variables to the values retrieved by the implementation." number="177" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="178" precision="empty"/><line any_info="No Anys on this line!" content="    def set_initial_record_offset_auto(self) -&gt; None:" number="179" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="180" precision="empty"/><line any_info="No Anys on this line!" content="        This method sets the initial values of the internal variables to the values retrieved by the implementation." number="181" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="182" precision="empty"/><line any_info="No Anys on this line!" content="" number="183" precision="empty"/><line any_info="No Anys on this line!" content="        self.set_initial_record_offset(self._load_input_record_offset())" number="184" precision="precise"/><line any_info="No Anys on this line!" content="" number="185" precision="empty"/><line any_info="No Anys on this line!" content="    def acknowledge_input(self) -&gt; None:" number="186" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="187" precision="empty"/><line any_info="No Anys on this line!" content="        This method sends the corresponding ack signal to the ChannelWriter" number="188" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="189" precision="empty"/><line any_info="No Anys on this line!" content="" number="190" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="        self.invoke_sync_send_status_message(ChannelStatus.Acknowledged)" number="191" precision="any"/><line any_info="No Anys on this line!" content="" number="192" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x1)" content="    def invoke_read_records(self) -&gt; list[Any]:" number="193" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="194" precision="empty"/><line any_info="No Anys on this line!" content="        An invoker method that encapsulates the actual implementation. This method" number="195" precision="empty"/><line any_info="No Anys on this line!" content="        MUST be called instead of the implemented method directly to ensure proper" number="196" precision="empty"/><line any_info="No Anys on this line!" content="        channel functionality." number="197" precision="empty"/><line any_info="No Anys on this line!" content="" number="198" precision="empty"/><line any_info="No Anys on this line!" content="        :return: list of read records or empty list in case no records read" number="199" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="200" precision="empty"/><line any_info="No Anys on this line!" content="" number="201" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x3)" content="        read_records = self._read_records()" number="202" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="203" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x2)" content="        read_record_count = len(read_records) if read_records is not None else 0" number="204" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="205" precision="empty"/><line any_info="No Anys on this line!" content="        if 0 &lt; read_record_count:" number="206" precision="precise"/><line any_info="No Anys on this line!" content="            self._read_record_count += read_record_count" number="207" precision="precise"/><line any_info="No Anys on this line!" content="            self._read_record_offset += read_record_count" number="208" precision="precise"/><line any_info="No Anys on this line!" content="            self._health_check_payload[&quot;receivedRecordCount&quot;] = self._read_record_count" number="209" precision="precise"/><line any_info="No Anys on this line!" content="" number="210" precision="empty"/><line any_info="No Anys on this line!" content="        if self._metrics_enabled:" number="211" precision="precise"/><line any_info="No Anys on this line!" content="            with self._status_sender_lock:" number="212" precision="precise"/><line any_info="No Anys on this line!" content="                if 0 &lt; self._current_read_timestamp:" number="213" precision="precise"/><line any_info="Any Types on this line: &#10;Unimported (x6)" content="                    new_metric = ChannelMetric(current_time_millis() - self._current_read_timestamp," number="214" precision="any"/><line any_info="No Anys on this line!" content="                                               self._current_read_record_count)" number="215" precision="precise"/><line any_info="No Anys on this line!" content="" number="216" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                    self._aggregated_time_between_reads += new_metric.elapsedTimeSinceLastIO" number="217" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                    self._aggregated_record_count += new_metric.recordCountInLastIO" number="218" precision="any"/><line any_info="No Anys on this line!" content="" number="219" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x3)" content="                    self._metrics_buffer.append(new_metric)" number="220" precision="any"/><line any_info="No Anys on this line!" content="" number="221" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)&#10;Unannotated (x1)" content="                    if ChannelReader.MetricsBufferLength == len(self._metrics_buffer):" number="222" precision="imprecise"/><line any_info="Any Types on this line: &#10;Unimported (x4)" content="                        old_metric = self._metrics_buffer.pop(0)" number="223" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                        self._aggregated_time_between_reads -= old_metric.elapsedTimeSinceLastIO" number="224" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                        self._aggregated_record_count -= old_metric.recordCountInLastIO" number="225" precision="any"/><line any_info="No Anys on this line!" content="" number="226" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                self._current_read_timestamp = current_time_millis()" number="227" precision="any"/><line any_info="No Anys on this line!" content="                self._current_read_record_count = read_record_count" number="228" precision="precise"/><line any_info="No Anys on this line!" content="" number="229" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x1)" content="        return read_records" number="230" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="231" precision="empty"/><line any_info="No Anys on this line!" content="    def on_status_message_send(self) -&gt; None:" number="232" precision="precise"/><line any_info="No Anys on this line!" content="        if self._metrics_enabled:" number="233" precision="precise"/><line any_info="No Anys on this line!" content="            with self._status_sender_lock:" number="234" precision="precise"/><line any_info="No Anys on this line!" content="                self._health_check_payload[&quot;elapsedTimeSinceLastReadCycleMs&quot;] = 0 if \" number="235" precision="precise"/><line any_info="Any Types on this line: &#10;Unimported (x3)" content="                    0 == self._current_read_timestamp else current_time_millis() - self._current_read_timestamp" number="236" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x1)" content="                self._health_check_payload[&quot;averageTimePerReadCycleMs&quot;] = 0 if 0 == len(self._metrics_buffer) else \" number="237" precision="imprecise"/><line any_info="Any Types on this line: &#10;Unimported (x1)" content="                    self._aggregated_time_between_reads / len(self._metrics_buffer)" number="238" precision="imprecise"/><line any_info="No Anys on this line!" content="                self._health_check_payload[&quot;averageTimePerReadRecordMs&quot;] = 0 \" number="239" precision="precise"/><line any_info="No Anys on this line!" content="                    if 0 == self._aggregated_record_count else \" number="240" precision="precise"/><line any_info="No Anys on this line!" content="                    self._aggregated_time_between_reads / self._aggregated_record_count" number="241" precision="precise"/><line any_info="Any Types on this line: &#10;Unimported (x1)" content="                self._health_check_payload[&quot;averageRecordPerReadCycle&quot;] = 0 if 0 == len(self._metrics_buffer) else \" number="242" precision="imprecise"/><line any_info="Any Types on this line: &#10;Unimported (x1)" content="                    self._aggregated_record_count / len(self._metrics_buffer)" number="243" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="244" precision="empty"/><line any_info="No Anys on this line!" content="    def invoke_commit_offset(self, offset: int, compensate_with_initial_offset: bool = True) -&gt; None:" number="245" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="246" precision="empty"/><line any_info="No Anys on this line!" content="        This method is used to invoke the implementation of the abstract method. This is necessary to perform some" number="247" precision="empty"/><line any_info="No Anys on this line!" content="        additional actions like compensating the calculated offset with the initial to make sure that the proper" number="248" precision="empty"/><line any_info="No Anys on this line!" content="        offset is committed. Note that this compensation makes only sense in case of crash-restart, since the initial" number="249" precision="empty"/><line any_info="No Anys on this line!" content="        values are probably not 0. Note that the provided offset is calculated by the calculateApplicableOffsetFrom" number="250" precision="empty"/><line any_info="No Anys on this line!" content="        by breaking down the calculated offset by the framework." number="251" precision="empty"/><line any_info="No Anys on this line!" content="" number="252" precision="empty"/><line any_info="No Anys on this line!" content="        :param offset: offset calculated by the plugin for this channel" number="253" precision="empty"/><line any_info="No Anys on this line!" content="        :param compensate_with_initial_offset: if True, the initial offset will be added to the provided offset" number="254" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="255" precision="empty"/><line any_info="No Anys on this line!" content="" number="256" precision="empty"/><line any_info="No Anys on this line!" content="        offset_to_commit = offset" number="257" precision="precise"/><line any_info="No Anys on this line!" content="" number="258" precision="empty"/><line any_info="No Anys on this line!" content="        if compensate_with_initial_offset:" number="259" precision="precise"/><line any_info="No Anys on this line!" content="            offset_to_commit += self._initial_input_record_offset" number="260" precision="precise"/><line any_info="No Anys on this line!" content="" number="261" precision="empty"/><line any_info="No Anys on this line!" content="            if offset_to_commit &gt; self._read_record_offset:" number="262" precision="precise"/><line any_info="No Anys on this line!" content="                raise ValueError(f&quot;Offset is out of range: {offset_to_commit}; &quot;" number="263" precision="precise"/><line any_info="No Anys on this line!" content="                                 f&quot;Current read offset? {self._read_record_offset}&quot;)" number="264" precision="precise"/><line any_info="No Anys on this line!" content="" number="265" precision="empty"/><line any_info="No Anys on this line!" content="        if offset_to_commit != self._last_offset_committed:" number="266" precision="precise"/><line any_info="No Anys on this line!" content="            self._commit_offset(offset_to_commit)" number="267" precision="precise"/><line any_info="No Anys on this line!" content="" number="268" precision="empty"/><line any_info="No Anys on this line!" content="            self._last_offset_committed = offset_to_commit" number="269" precision="precise"/><line any_info="No Anys on this line!" content="" number="270" precision="empty"/><line any_info="No Anys on this line!" content="        if offset_to_commit &lt; self._last_offset_committed:" number="271" precision="precise"/><line any_info="No Anys on this line!" content="            self._logger.warn(f&quot;!WARNING! Offset to commit ({offset_to_commit}) &quot;" number="272" precision="precise"/><line any_info="No Anys on this line!" content="                              f&quot;is lower than the last committed offset ({self._last_offset_committed}). &quot;" number="273" precision="precise"/><line any_info="No Anys on this line!" content="                              f&quot;Commit ignored.&quot;)" number="274" precision="empty"/><line any_info="No Anys on this line!" content="" number="275" precision="empty"/><line any_info="No Anys on this line!" content="    def invoke_commit_current_read_offset(self) -&gt; None:" number="276" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="277" precision="empty"/><line any_info="No Anys on this line!" content="        This method is used to invoke the implementation of the abstract method." number="278" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="279" precision="empty"/><line any_info="No Anys on this line!" content="" number="280" precision="empty"/><line any_info="No Anys on this line!" content="        self.invoke_commit_offset(self._read_record_offset, False)" number="281" precision="precise"/><line any_info="No Anys on this line!" content="" number="282" precision="empty"/><line any_info="No Anys on this line!" content="" number="283" precision="empty"/><line any_info="No Anys on this line!" content="class ChannelWriter(ChannelBase):" number="284" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="285" precision="empty"/><line any_info="No Anys on this line!" content="    This class is the base of the output channel classes." number="286" precision="empty"/><line any_info="No Anys on this line!" content="    The idea is that the class provides some core, protected abstract methods, which shall be implemented by" number="287" precision="empty"/><line any_info="No Anys on this line!" content="    the developer. These implementations then will be invoked by invoker methods. This makes sure that additional" number="288" precision="empty"/><line any_info="No Anys on this line!" content="    necessary logic will be performed along the implemented." number="289" precision="empty"/><line any_info="No Anys on this line!" content="" number="290" precision="empty"/><line any_info="No Anys on this line!" content="    :param channel_name: name of the channel" number="291" precision="empty"/><line any_info="No Anys on this line!" content="    :param context: the :class:`PortPlugin &lt;pypz.core.specs.plugin.PortPlugin&gt;`, which operates this channel" number="292" precision="empty"/><line any_info="No Anys on this line!" content="    :param executor: an external ThreadPoolExecutor, if not provided, on will be created internally" number="293" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="294" precision="empty"/><line any_info="No Anys on this line!" content="" number="295" precision="empty"/><line any_info="No Anys on this line!" content="    MetricsBufferLength = 10" number="296" precision="precise"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="297" precision="empty"/><line any_info="No Anys on this line!" content="    This variable specifies the length of the metric buffer and so the averaging window" number="298" precision="empty"/><line any_info="No Anys on this line!" content="    &quot;&quot;&quot;" number="299" precision="empty"/><line any_info="No Anys on this line!" content="" number="300" precision="empty"/><line any_info="No Anys on this line!" content="    # ======================= Ctor =======================" number="301" precision="empty"/><line any_info="No Anys on this line!" content="" number="302" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x1)&#10;Unannotated (x1)" content="    def __init__(self, channel_name: str," number="303" precision="any"/><line any_info="No Anys on this line!" content="                 context: 'OutputPortPlugin'," number="304" precision="empty"/><line any_info="No Anys on this line!" content="                 executor: Optional[concurrent.futures.ThreadPoolExecutor] = None," number="305" precision="precise"/><line any_info="No Anys on this line!" content="                 **kwargs):" number="306" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x1)&#10;Unannotated (x1)" content="        super().__init__(channel_name, context, executor, **kwargs)" number="307" precision="any"/><line any_info="No Anys on this line!" content="" number="308" precision="empty"/><line any_info="No Anys on this line!" content="        self._written_record_count: int = 0" number="309" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="310" precision="empty"/><line any_info="No Anys on this line!" content="        Number of outputted records." number="311" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="312" precision="empty"/><line any_info="No Anys on this line!" content="" number="313" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x3)&#10;Omitted Generics (x3)" content="        self._metrics_buffer: list[ChannelMetric] = list()" number="314" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="315" precision="empty"/><line any_info="No Anys on this line!" content="        This list holds metric elements, however the only purpose is to be aware of the first" number="316" precision="empty"/><line any_info="No Anys on this line!" content="        element to discard like in a circular buffer" number="317" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="318" precision="empty"/><line any_info="No Anys on this line!" content="" number="319" precision="empty"/><line any_info="No Anys on this line!" content="        self._aggregated_time_between_outputs: int = 0" number="320" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="321" precision="empty"/><line any_info="No Anys on this line!" content="        Metric value to store the summed up times between reads" number="322" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="323" precision="empty"/><line any_info="No Anys on this line!" content="" number="324" precision="empty"/><line any_info="No Anys on this line!" content="        self._aggregated_record_count: int = 0" number="325" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="326" precision="empty"/><line any_info="No Anys on this line!" content="        Metric value to store the summed up record count" number="327" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="328" precision="empty"/><line any_info="No Anys on this line!" content="" number="329" precision="empty"/><line any_info="No Anys on this line!" content="        self._current_output_timestamp: int = 0" number="330" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="331" precision="empty"/><line any_info="No Anys on this line!" content="        Stores the timestamp of the most current read to be able to calculate elapsed time" number="332" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="333" precision="empty"/><line any_info="No Anys on this line!" content="" number="334" precision="empty"/><line any_info="No Anys on this line!" content="        self._current_output_record_count: int = 0" number="335" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="336" precision="empty"/><line any_info="No Anys on this line!" content="        Stores the record count of the most current read" number="337" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="338" precision="empty"/><line any_info="No Anys on this line!" content="" number="339" precision="empty"/><line any_info="No Anys on this line!" content="        self._status_sender_lock = threading.Lock()" number="340" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="341" precision="empty"/><line any_info="No Anys on this line!" content="        This lock is used to prevent concurrent modification of metrics" number="342" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="343" precision="empty"/><line any_info="No Anys on this line!" content="" number="344" precision="empty"/><line any_info="No Anys on this line!" content="    # ======================= Abstract methods =======================" number="345" precision="empty"/><line any_info="No Anys on this line!" content="" number="346" precision="empty"/><line any_info="No Anys on this line!" content="    @abstractmethod" number="347" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x1)" content="    def _write_records(self, records: list[Any]) -&gt; None:" number="348" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="349" precision="empty"/><line any_info="No Anys on this line!" content="        This method shall implement the logic that writes the records to the output resource. It will automatically" number="350" precision="empty"/><line any_info="No Anys on this line!" content="        be invoked by the plugin via the corresponding invoker method." number="351" precision="empty"/><line any_info="No Anys on this line!" content="" number="352" precision="empty"/><line any_info="No Anys on this line!" content="        :param records: list of records to be written" number="353" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="354" precision="empty"/><line any_info="No Anys on this line!" content="        pass" number="355" precision="precise"/><line any_info="No Anys on this line!" content="" number="356" precision="empty"/><line any_info="No Anys on this line!" content="    # ======================= Getter/setter/invoker methods =======================" number="357" precision="empty"/><line any_info="No Anys on this line!" content="" number="358" precision="empty"/><line any_info="No Anys on this line!" content="    def get_written_record_count(self):" number="359" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)" content="        return self._written_record_count" number="360" precision="any"/><line any_info="No Anys on this line!" content="" number="361" precision="empty"/><line any_info="No Anys on this line!" content="    def is_all_connected_input_channels_acknowledged(self) -&gt; bool:" number="362" precision="precise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="363" precision="empty"/><line any_info="No Anys on this line!" content="        This method retrieves the number of InputChannels that have acknowledged their input (i.e. the output of" number="364" precision="empty"/><line any_info="No Anys on this line!" content="        this channel). This information can be useful for scenarios, where a synchronization logic needs to be" number="365" precision="empty"/><line any_info="No Anys on this line!" content="        implemented e.g. where the output shall not provide more data until the inputs did not acknowledge. Note" number="366" precision="empty"/><line any_info="No Anys on this line!" content="        that the state is maintained entirely by the ChannelWriter i.e. if the ChannelReader sent the proper message," number="367" precision="empty"/><line any_info="No Anys on this line!" content="        a flag will be set in the corresponding entry of the status map. Then this flag will be reset once this" number="368" precision="empty"/><line any_info="No Anys on this line!" content="        ChannelWriter produces new data (check invoke_write_records() for more detail)." number="369" precision="empty"/><line any_info="No Anys on this line!" content="" number="370" precision="empty"/><line any_info="No Anys on this line!" content="        :return: number of acknowledged InputChannels" number="371" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="372" precision="empty"/><line any_info="No Anys on this line!" content="" number="373" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="        for status_monitor in list(self._status_map.values()):" number="374" precision="precise"/><line any_info="No Anys on this line!" content="            if status_monitor.is_channel_healthy() and \" number="375" precision="precise"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                    (ChannelStatus.Acknowledged not in status_monitor.status_update_map):" number="376" precision="any"/><line any_info="No Anys on this line!" content="                return False" number="377" precision="precise"/><line any_info="No Anys on this line!" content="        return True" number="378" precision="precise"/><line any_info="No Anys on this line!" content="" number="379" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x1)" content="    def invoke_write_records(self, records: list[Any]) -&gt; None:" number="380" precision="imprecise"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="381" precision="empty"/><line any_info="No Anys on this line!" content="        This method is used to invoke the implementation of the abstract method. This is necessary to perform some" number="382" precision="empty"/><line any_info="No Anys on this line!" content="        additional actions e.g. updating number of outputted records." number="383" precision="empty"/><line any_info="No Anys on this line!" content="" number="384" precision="empty"/><line any_info="No Anys on this line!" content="        :param records: records to be written" number="385" precision="empty"/><line any_info="No Anys on this line!" content="        &quot;&quot;&quot;" number="386" precision="empty"/><line any_info="No Anys on this line!" content="" number="387" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x2)" content="        self._write_records(records)" number="388" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="389" precision="empty"/><line any_info="Any Types on this line: &#10;Explicit (x1)" content="        output_record_count = len(records)" number="390" precision="imprecise"/><line any_info="No Anys on this line!" content="" number="391" precision="empty"/><line any_info="No Anys on this line!" content="        self._written_record_count += output_record_count" number="392" precision="precise"/><line any_info="No Anys on this line!" content="" number="393" precision="empty"/><line any_info="No Anys on this line!" content="        self._health_check_payload[&quot;sentRecordCount&quot;] = self._written_record_count" number="394" precision="precise"/><line any_info="No Anys on this line!" content="" number="395" precision="empty"/><line any_info="No Anys on this line!" content="        # We need to set the acknowledged flag to false, since we output new data to be acknowledged" number="396" precision="empty"/><line any_info="Any Types on this line: &#10;Omitted Generics (x3)" content="        for status_monitor in list(self._status_map.values()):" number="397" precision="precise"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="            if ChannelStatus.Acknowledged in status_monitor.status_update_map:" number="398" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                del status_monitor.status_update_map[ChannelStatus.Acknowledged]" number="399" precision="any"/><line any_info="No Anys on this line!" content="" number="400" precision="empty"/><line any_info="No Anys on this line!" content="        if self._metrics_enabled:" number="401" precision="precise"/><line any_info="No Anys on this line!" content="            with self._status_sender_lock:" number="402" precision="precise"/><line any_info="No Anys on this line!" content="                if 0 &lt; self._current_output_timestamp:" number="403" precision="precise"/><line any_info="Any Types on this line: &#10;Unimported (x6)" content="                    new_metric = ChannelMetric(current_time_millis() - self._current_output_timestamp," number="404" precision="any"/><line any_info="No Anys on this line!" content="                                               self._current_output_record_count)" number="405" precision="precise"/><line any_info="No Anys on this line!" content="" number="406" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                    self._aggregated_time_between_outputs += new_metric.elapsedTimeSinceLastIO" number="407" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                    self._aggregated_record_count += new_metric.recordCountInLastIO" number="408" precision="any"/><line any_info="No Anys on this line!" content="" number="409" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x3)" content="                    self._metrics_buffer.append(new_metric)" number="410" precision="any"/><line any_info="No Anys on this line!" content="" number="411" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)&#10;Unannotated (x1)" content="                    if ChannelWriter.MetricsBufferLength == len(self._metrics_buffer):" number="412" precision="imprecise"/><line any_info="Any Types on this line: &#10;Unimported (x4)" content="                        old_metric = self._metrics_buffer.pop(0)" number="413" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                        self._aggregated_time_between_outputs -= old_metric.elapsedTimeSinceLastIO" number="414" precision="any"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                        self._aggregated_record_count -= old_metric.recordCountInLastIO" number="415" precision="any"/><line any_info="No Anys on this line!" content="" number="416" precision="empty"/><line any_info="Any Types on this line: &#10;Unimported (x2)" content="                self._current_output_timestamp = current_time_millis()" number="417" precision="any"/><line any_info="No Anys on this line!" content="                self._current_output_record_count = output_record_count" number="418" precision="precise"/><line any_info="No Anys on this line!" content="" number="419" precision="empty"/><line any_info="No Anys on this line!" content="    def on_status_message_send(self):" number="420" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)" content="        if self._metrics_enabled:" number="421" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)" content="            with self._status_sender_lock:" number="422" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)" content="                self._health_check_payload[&quot;elapsedTimeSinceLastOutputCycleMs&quot;] = 0 \" number="423" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x5)&#10;Unimported (x1)" content="                    if 0 == self._current_output_timestamp else current_time_millis() - self._current_output_timestamp" number="424" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)" content="                self._health_check_payload[&quot;averageTimePerOutputCycleMs&quot;] = 0 if 0 == len(self._metrics_buffer) else \" number="425" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)" content="                    self._aggregated_time_between_outputs / len(self._metrics_buffer)" number="426" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x1)" content="                self._health_check_payload[&quot;averageTimePerOutputRecordMs&quot;] = 0 \" number="427" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x2)" content="                    if 0 == self._aggregated_record_count else \" number="428" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x3)" content="                    self._aggregated_time_between_outputs / self._aggregated_record_count" number="429" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)" content="                self._health_check_payload[&quot;averageRecordPerOutputCycle&quot;] = 0 if 0 == len(self._metrics_buffer) else \" number="430" precision="any"/><line any_info="Any Types on this line: &#10;Unannotated (x4)" content="                    self._aggregated_record_count / len(self._metrics_buffer)" number="431" precision="any"/></mypy-report-file>